////////////////////////////////////////////////////////////////////////
// Class:       TripleMatchingAna
// Plugin Type: analyzer (Unknown Unknown)
// File:        TripleMatchingAna_module.cc
//
// Generated by Francesco Poppi on May 02 2024
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art_root_io/TFileService.h"
#include "canvas/Persistency/Common/FindMany.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

// LArSoft includes
#include "larcore/CoreUtils/ServiceUtil.h"
#include "larcore/Geometry/Geometry.h"
#include "larcorealg/Geometry/GeometryCore.h"
#include "lardata/DetectorInfoServices/DetectorClocksService.h"
#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/AnalysisBase/T0.h"
#include "lardataobj/RecoBase/PFParticleMetadata.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/TrackHitMeta.h"

// Data product includes
#include "icaruscode/CRT/CRTUtils/CRTBackTracker.h"
#include "icaruscode/CRT/CRTUtils/CRTCommonUtils.h"
#include "icaruscode/Decode/DataProducts/TriggerConfiguration.h"
#include "larcorealg/CoreUtils/enumerate.h"
#include "lardataobj/RecoBase/OpFlash.h"
#include "lardataobj/RecoBase/OpHit.h"
#include "nusimdata/SimulationBase/MCGeneratorInfo.h"
#include "nusimdata/SimulationBase/MCParticle.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "sbnobj/Common/CRT/CRTHit.hh"
#include "sbnobj/Common/CRT/CRTTrack.hh"
#include "sbnobj/Common/Trigger/ExtraTriggerInfo.h"
#include "sbnobj/Common/CRT/CRTPMTMatching.hh"

// C++ includes
#include <map>
#include <numeric>
#include <vector>
#include <optional>

// ROOT includes
#include "TTree.h"
#include "TVector3.h"

using std::map;
using std::vector;

namespace icarus {
namespace crt {

class TripleMatchingAna;

namespace triplematching {
double const vdrift=0.157; //cm/us
double const tics=0.4; // 0.4 us, 400 ns
double const minLimitW=61.7; // cm Anode WE position
double const maxLimitW=358.73; // cm Anode WW position
double const minLimitE=-61.7; // cm Anode EW position
double const maxLimitE=-358.73; // cm Anode WW position
double const cathW=210; // cm Cathode W position
double const cathE=-210; // cm Cathode E position
double const exc=2; // cm max displacement out of boundaries

struct TrackBarycenter {
    float BarX; // Track Barycenter X coordinate
    float BarY; // Track Barycenter Y coordinate
    float BarZ; // Track Barycenter Z coordinate
    bool isGood; // Track Barycenter quality
};

struct DriftedTrack {
    std::vector<float> spx; // Drifted Track Hit Points X coordinate
    std::vector<float> spy; // Drifted Track Hit Points Y coordinate
    std::vector<float> spz; // Drifted Track Hit Points Z coordinate
    int outbound; // Number of hit points out of the logical volume of the TPC
    double startx; // Drifted Track StartX coordinate
    double endx; // Drifted Track EndX coordinate
};

TrackBarycenter GetTrackBarycenter (std::vector<float> hx, std::vector<float> hy, std::vector<float> hz, std::vector<float> hi){
    float average_z_charge=0;
    float average_y_charge=0;
    float average_x_charge=0;
    float total_charge=0;
    bool isGood;
    for (unsigned i = 0; i < hz.size(); i++) {
        if(isnan(hz[i])) continue;
        
        if(hz[i]>-1000 && hz[i]<1000){
            average_z_charge+=hz[i]*hi[i];
            average_y_charge+=hy[i]*hi[i];
            average_x_charge+=hx[i]*hi[i];
            total_charge+=hi[i];
        }
    }
    average_z_charge=average_z_charge/total_charge;
    average_y_charge=average_y_charge/total_charge;
    average_x_charge=average_x_charge/total_charge;
    if(total_charge==0) isGood=false;
    else isGood=true;
    TrackBarycenter ThisTrackBary = {average_x_charge, average_y_charge, average_z_charge, isGood};
    return ThisTrackBary;
}

void DriftTrack (std::vector<art::Ptr<recob::Hit>>* hits, double time, int cryo){
  //int outBound=0;
  /*double cath;
  double maxLimit;
  double minLimit;
  std::vector<float> recX, recY, recZ;
  if(cryo==0){ // this Cryo is East
      cath=cathE;
      maxLimit=maxLimitE;
      minLimit=minLimitE;        
  } else if(cryo==1) { // this Cryo is West
      cath=cathW;
      maxLimit=maxLimitW;
      minLimit=minLimitW;                
  }*/
  for(size_t j=0; j<hits->size(); j++){
      //std::cout<<"Hit number "<<j<<" integral "<<hits.at(j)->Integral()<<" time "<<hits.at(j)->PeakTime()<<" plane "<<hits.at(j)->WireID().Plane<<" TPC "<<hits.at(j)->WireID().TPC<<std::endl;
      //int driftDirection = DriftDirection(ogTrack.tpc[i]);
      double recoX = (hits->at(j)->PeakTime()-846-time/tics)*tics*vdrift;
      std::cout<<"Hit "<<j<<" Tic "<<hits->at(j)->PeakTime()<<" recoX "<<recoX<<std::endl;
  }
  /* for(size_t i = 0; i < ogTrack.spx.size(); i++){
      //if(isnan(ogTrack.spx[i])) continue;
      int driftDirection = DriftDirection(ogTrack.tpc[i]);
      double recoX = (ogTrack.tic[i]-846-time/tics)*tics*vdrift;
      double planeX;
      double realX; 
      if(driftDirection==-1 && cryo==1) {
          planeX=minLimit;
          realX=planeX+recoX;
      } else if (driftDirection==1 && cryo==1) {
          planeX=maxLimit;
          realX=planeX-recoX;
      } else if (driftDirection==-1 && cryo==0) {
          planeX=maxLimit;
          realX=planeX+recoX;
      } else if (driftDirection==1 && cryo==0) {
          planeX=minLimit;
          realX=planeX-recoX;
      }
      if(cryo==1){
          if(ogTrack.tpc[i]==0 || ogTrack.tpc[i]==1){
              if(realX>(cath+exc)||realX<(minLimit-exc)){
                  //std::cout<<"Fuori dalla Drift Region 0/1 "<<std::endl;
                  outBound++;
              }
          }
          if(ogTrack.tpc[i]==2 || ogTrack.tpc[i]==3){
              if(realX<(cath-TripleMatchingUtils::exc)||realX>(maxLimit+TripleMatchingUtils::exc)){
                  outBound++;
              }
          }
      } else if (cryo==0) {
          if(ogTrack.tpc[i]==0 || ogTrack.tpc[i]==1){
              if(realX>(cath+TripleMatchingUtils::exc)||realX<(maxLimit-TripleMatchingUtils::exc)){
                  //std::cout<<"Fuori dalla Drift Region 0/1 "<<std::endl;
                  outBound++;
              }
          }
          if(ogTrack.tpc[i]==2 || ogTrack.tpc[i]==3){
              if(realX<(cath-TripleMatchingUtils::exc)||realX>(minLimit+TripleMatchingUtils::exc)){
                  outBound++;
              }
          }
      }
      //if(abs(hx[i]-realX)<15 && realX<0)std::cout<<"Real X "<< hx[i] <<" Reco X  "<<recoX<<" TPC  "<<htpc[i]<<"  realX "<<realX<<"  outbound "<<outBound<<std::endl;
      
      recX.push_back(realX);
      recY.push_back(ogTrack.spy[i]);
      recZ.push_back(ogTrack.spz[i]);
      if(ogTrack.spx[i]==ogTrack.startx && ogTrack.spy[i]==ogTrack.starty && ogTrack.spz[i]==ogTrack.startz) {
          startx=realX;
      }
      if(ogTrack.spx[i]==ogTrack.endx && ogTrack.spy[i]==ogTrack.endy && ogTrack.spz[i]==ogTrack.endz){
          endx=realX; 
      }
      
  }
  TripleMatchingUtils::DriftedTrack thisDriftedTrack = {recX, recY, recZ, outBound, startx, endx};
  return thisDriftedTrack;*/
}


}  // namespace triplematching
}  // namespace crt
}  // namespace icarus

using namespace icarus::crt;

class icarus::crt::TripleMatchingAna : public art::EDAnalyzer {
 public:
  using CRTHit = sbn::crt::CRTHit;
  using CRTPMTMatching = sbn::crt::CRTPMTMatching;
  explicit TripleMatchingAna(fhicl::ParameterSet const& p);
  // The compiler-generated destructor is fine for non-base
  // classes without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  TripleMatchingAna(TripleMatchingAna const&) = delete;
  TripleMatchingAna(TripleMatchingAna&&) = delete;
  TripleMatchingAna& operator=(TripleMatchingAna const&) = delete;
  TripleMatchingAna& operator=(TripleMatchingAna&&) = delete;

  // Required functions.
  void beginRun(art::Run const& r) override;
  void analyze(art::Event const& e) override;

 private:
  // Declare member data here.

  void ClearVecs();

  // art::InputTag fOpHitModuleLabel;
  art::InputTag fOpFlashModuleLabel0;
  art::InputTag fOpFlashModuleLabel1;
  art::InputTag fOpFlashModuleLabel2;
  art::InputTag fOpFlashModuleLabel3;
  art::InputTag fCrtHitModuleLabel;
  art::InputTag fTriggerLabel;
  art::InputTag fTriggerConfigurationLabel;
  art::InputTag fCrtPmtModuleLabel;
  // tart::InputTag fCrtTrackModuleLabel;
  std::vector<art::InputTag> fTPCTrackLabel; ///< labels for source of tracks
  std::vector<art::InputTag> fPFParticleLabel; ///< labels for source of PFParticle
  
  std::optional<icarus::TriggerConfiguration> fTriggerConfiguration;

  int fEvent;   ///< number of the event being processed
  int fRun;     ///< number of the run being processed
  int fSubRun;  ///< number of the sub-run being processed
  double fTrackLength; ///< track length
  double fTrackStartX; ///< track startX
  double fTrackStartY; ///< track startY
  double fTrackStartZ; ///< track startZ
  double fTrackEndX; ///< track endX
  double fTrackEndY; ///< track endY
  double fTrackEndZ; ///< track endZ
  double fTrackScore; ///< track score
  double fNuScore; ///< nu score
  double fClearCosmic; ///< clear cosmic
  int fSizeHits; ///< nhits of the Tracks
  double fT0Track; ///< time of the Tracks
  double fDirStartx; ///< dirx of Start
  double fDirStarty; ///< diry of Start
  double fDirStartz; ///< dirz of Start
  double fDirEndx; ///< endx of Start
  double fDirEndy; ///< endy of Start
  double fDirEndz; ///< endz of Start
  double fDirXAvg;
  double fDirYAvg;
  double fDirZAvg;
  std::vector<float> fTPx;
  std::vector<float> fTPy;
  std::vector<float> fTPz;
  int fIDTrack;
  int fCryo;

  // add trigger data product vars
  unsigned int m_gate_type;
  std::string m_gate_name;
  uint64_t m_trigger_timestamp;
  uint64_t m_gate_start_timestamp;
  uint64_t m_trigger_gate_diff;
  // uint64_t m_gate_crt_diff;
  uint64_t m_gate_width;

  //  CRTBackTracker* bt;
  CRTCommonUtils* crtutil;

  std::vector<art::InputTag> fFlashLabels;

  TTree* fMatchTree;

  // matchTree vars

  geo::GeometryCore const* fGeometryService;  ///< pointer to Geometry provider
};

icarus::crt::TripleMatchingAna::TripleMatchingAna(fhicl::ParameterSet const& p)
    : EDAnalyzer{p}  // ,
      //,fOpHitModuleLabel(p.get<art::InputTag>("OpHitModuleLabel","ophit"))
      ,
      fOpFlashModuleLabel0(
          p.get<art::InputTag>("OpFlashModuleLabel0")),
      fOpFlashModuleLabel1(
          p.get<art::InputTag>("OpFlashModuleLabel1")),
      fCrtHitModuleLabel(p.get<art::InputTag>("CrtHitModuleLabel", "crthit")),
      fTriggerLabel(p.get<art::InputTag>("TriggerLabel", "daqTrigger")),
      fTriggerConfigurationLabel(
          p.get<art::InputTag>("TriggerConfiguration", "triggerconfig")),
      fCrtPmtModuleLabel(p.get<art::InputTag>("CrtPmtModuleLabel")),
      fTPCTrackLabel(p.get< std::vector<art::InputTag> >("TPCTrackLabel",             {""})),
      fPFParticleLabel(p.get< std::vector<art::InputTag> >("PFParticleLabel",             {""})),  
      crtutil(new CRTCommonUtils())
// More initializers here.
{
  // Call appropriate consumes<>() for any products to be retrieved by this
  // module.
  fFlashLabels.push_back(fOpFlashModuleLabel0);
  fFlashLabels.push_back(fOpFlashModuleLabel1);

  // Get a pointer to the geometry service provider.
  fGeometryService = lar::providerFrom<geo::Geometry>();

  art::ServiceHandle<art::TFileService> tfs;

  fMatchTree =
      tfs->make<TTree>("matchTree", "CRTHit - OpHit/Flash matching analysis");

  fMatchTree->Branch("event", &fEvent, "event/I");
  fMatchTree->Branch("run", &fRun, "run/I");
  fMatchTree->Branch("subrun", &fSubRun, "subrun/I");
  fMatchTree->Branch("track_length", &fTrackLength);
  fMatchTree->Branch("track_startX", &fTrackStartX);
  fMatchTree->Branch("track_startY", &fTrackStartY);
  fMatchTree->Branch("track_startZ", &fTrackStartZ);
  fMatchTree->Branch("track_endX", &fTrackEndX);
  fMatchTree->Branch("track_endY", &fTrackEndY);
  fMatchTree->Branch("track_endZ", &fTrackEndZ);
  fMatchTree->Branch("TrackScore", &fTrackScore);
  fMatchTree->Branch("NuScore", &fNuScore);
  fMatchTree->Branch("ClearCosmic", &fClearCosmic);
  fMatchTree->Branch("nHits", &fSizeHits);
  fMatchTree->Branch("T0", &fT0Track);
  fMatchTree->Branch("dirXAvg", &fDirXAvg);
  fMatchTree->Branch("dirYAvg", &fDirYAvg);
  fMatchTree->Branch("dirZAvg", &fDirZAvg);
  fMatchTree->Branch("TrackID", &fIDTrack);
  fMatchTree->Branch("TPX", &fTPx);
  fMatchTree->Branch("TPY", &fTPy);
  fMatchTree->Branch("TPZ", &fTPz);
  fMatchTree->Branch("cryo", &fCryo);

}


void icarus::crt::TripleMatchingAna::beginRun(art::Run const& r) {
  
  // we don't know if this is data or not; if not, there will be no trigger config
  auto const& trigConfHandle = 
    r.getHandle<icarus::TriggerConfiguration>(fTriggerConfigurationLabel);
  
  fTriggerConfiguration
    = trigConfHandle.isValid()? std::make_optional(*trigConfHandle): std::nullopt;

}


void icarus::crt::TripleMatchingAna::analyze(art::Event const& e) {
  // Implementation of required member function here.
  
  if (!fTriggerConfiguration) {
    mf::LogDebug("TripleMatchingAna")
      << "Skipping because no data (or at least no trigger configuration).";
    return;
  }
  
  mf::LogDebug("TripleMatchingAna: ") << "beginning analyis" << '\n';
  // Start by fetching some basic event information for our n-tuple.
  fEvent = e.id().event();
  fRun = e.run();
  fSubRun = e.subRun();
  ClearVecs();

  // add trigger info
  if (!fTriggerLabel.empty()) {
    art::Handle<sbn::ExtraTriggerInfo> trigger_handle;
    e.getByLabel(fTriggerLabel, trigger_handle);
    if (trigger_handle.isValid()) {
      sbn::triggerSource bit = trigger_handle->sourceType;
      m_gate_type = (unsigned int)bit;
      m_gate_name = bitName(bit);
      m_trigger_timestamp = trigger_handle->triggerTimestamp;
      m_gate_start_timestamp = trigger_handle->beamGateTimestamp;
      m_trigger_gate_diff =
          trigger_handle->triggerTimestamp - trigger_handle->beamGateTimestamp;
      // Read Beam Gate Size
      m_gate_width = fTriggerConfiguration->getGateWidth(m_gate_type);
    } else {
      mf::LogError("TripleMatchingAna:")
          << "No sbn::ExtraTriggerInfo associated to label: "
          << fTriggerLabel.encode() << "\n";
    }
  } else {
    // std::cout  << "Trigger Data product " << fTriggerLabel.label() << " not
    // found!\n" ;
  }

  // OpFlash
  std::array<art::Handle<std::vector<recob::OpFlash>>, 2U> flashHandles;
  for (int i = 0; i < 2; i++) {
    flashHandles[i] = e.getHandle<std::vector<recob::OpFlash>>(fFlashLabels[i]);
  }

  // CRTHits
  art::Handle<std::vector<CRTHit>> crtHitListHandle;
  std::vector<art::Ptr<CRTHit>> crtHitList;
  if (e.getByLabel(fCrtHitModuleLabel, crtHitListHandle))
    art::fill_ptr_vector(crtHitList, crtHitListHandle);

  // fNCrt = crtHitList.size();

  auto const& crtpmtMatches = e.getProduct<std::vector<CRTPMTMatching>>(fCrtPmtModuleLabel);
  auto const crtpmtHandle = e.getHandle<std::vector<CRTPMTMatching>>(fCrtPmtModuleLabel);
  art::FindMany<CRTHit> fmCRTHits(crtpmtHandle, e, fCrtPmtModuleLabel);
  art::FindMany<recob::OpFlash> fmCRTPMTFlash(crtpmtHandle, e, fCrtPmtModuleLabel);

  // Tracks
  int cryo=-1;
  int thisTrackID=-1;
  for(const auto& trackLabel : fTPCTrackLabel) {
    cryo++;
    auto it = &trackLabel - fTPCTrackLabel.data();
    // Get reconstructed tracks from the event    
    auto tpcTrackHandle = e.getValidHandle<std::vector<recob::Track>>(trackLabel);
    if (!tpcTrackHandle.isValid()) continue;

    //Get PFParticles
    auto pfpListHandle = e.getValidHandle<std::vector<recob::PFParticle> >(fPFParticleLabel[it]);
    if (!pfpListHandle.isValid()) continue;

    //Get PFParticle-Track association
    art::FindManyP<recob::PFParticle> fmpfp(tpcTrackHandle, e, trackLabel); 

    //Get T0-PFParticle association
    art::FindManyP<anab::T0> fmt0pandora(pfpListHandle, e, fPFParticleLabel[it]);
    art::FindManyP<larpandoraobj::PFParticleMetadata> PFPMetaDataAssoc(pfpListHandle, e, fPFParticleLabel[it]);
    art::FindManyP<recob::Hit> findManyHits(tpcTrackHandle, e, trackLabel);
    art::FindManyP<recob::Hit, recob::TrackHitMeta> fmtrkHits(tpcTrackHandle, e, trackLabel);

    //std::cout<<"Label "<<trackLabel<<std::endl;
    for (auto const& tpcTrack : (*tpcTrackHandle)){
      thisTrackID++;
      if(tpcTrack.Length()>30){
        std::cout<<"This Track is long "<<tpcTrack.Length()<<std::endl;
        std::cout<<"This Track start "<<tpcTrack.Start().X()<<" "<<tpcTrack.Start().Y()<<" "<<tpcTrack.Start().Z()<<std::endl;
        std::cout<<"This Track end "<<tpcTrack.End().X()<<" "<<tpcTrack.End().Y()<<" "<<tpcTrack.End().Z()<<std::endl;
      }
      fTrackLength=tpcTrack.Length();
      fTrackStartX=tpcTrack.Start().X();
      fTrackStartY=tpcTrack.Start().Y();
      fTrackStartZ=tpcTrack.Start().Z();
      fTrackEndX=tpcTrack.End().X();
      fTrackEndY=tpcTrack.End().Y();
      fTrackEndZ=tpcTrack.End().Z();
      
	    //auto idx = &tpcTrack - (*tpcTrackHandle).data();
      double t0 = -999999999;
	    //Find PFParticle for track i
	    //art::Ptr::key() gives the index in the vector 
	    auto pfps = fmpfp.at(tpcTrack.ID());
	    if (!pfps.empty()){
	      //Find T0 for PFParticle
	      auto t0s = fmt0pandora.at(pfps[0].key()); 
	      if (!t0s.empty()){  
	        t0 = t0s[0]->Time();   //Get T0  
          //std::cout<<"The Slice is not empty, size "<<pfps.size()<<std::endl;
	      }
        auto const pfpmeta = PFPMetaDataAssoc.at(pfps[0].key());
        //std::cout<<"Type of pfpmeta "<<typeid(pfpmeta[0]).name()<<std::endl;
        auto const &propertiesMap (pfpmeta[0]->GetPropertiesMap());
        auto const &pfpTrackScoreIter(propertiesMap.find("TrackScore"));
        double trackScore = (pfpTrackScoreIter == propertiesMap.end()) ? -5.f : pfpTrackScoreIter->second;
        auto const &pfpNuScoreIter(propertiesMap.find("NuScore"));
        double nuScore = (pfpNuScoreIter == propertiesMap.end()) ? -5.f : pfpNuScoreIter->second;
        auto const &pfpIsClearCosmicScoreIter(propertiesMap.find("IsClearCosmic"));
        double isClearCosmic = (pfpIsClearCosmicScoreIter == propertiesMap.end()) ? -5.f : pfpIsClearCosmicScoreIter->second;
        //std::cout<<"Track Score "<<trackScore<<" ; NuScore "<<nuScore<<" ; isClearCosmic "<<isClearCosmic<<std::endl;
        fTrackScore=trackScore;
        fNuScore=nuScore;
        fClearCosmic=isClearCosmic;
      }
      //std::cout<<"Type of pfps "<<typeid(pfps).name()<<std::endl;
      std::vector<art::Ptr<recob::Hit>> hits = findManyHits.at(tpcTrack.ID());
      const std::vector<const recob::TrackHitMeta*> hitsmeta=fmtrkHits.data(tpcTrack.ID());
	    //std::cout<< "This Track has hits "<<hits.size()<<" and meta size "<<hitsmeta.size()<<" entries and T0: " <<  (Long64_t) t0 << std::endl;
      fSizeHits=hits.size();
      fT0Track=t0;
      double dirXAvg=0, dirYAvg=0, dirZAvg=0;
      std::vector<float> hx, hy, hz, hi;
      int gCounts=0;
      for(size_t j=0; j<hits.size(); j++){
        //std::cout<<"Hit number "<<j<<" integral "<<hits.at(j)->Integral()<<" time "<<hits.at(j)->PeakTime()<<" plane "<<hits.at(j)->WireID().Plane<<" TPC "<<hits.at(j)->WireID().TPC<<std::endl;
        geo::Point_t loc = tpcTrack.LocationAtPoint(j);
        geo::Vector_t dir = tpcTrack.DirectionAtPoint(j);
        if(loc.X()==-999) continue;
        dirXAvg+=dir.X();
        dirYAvg+=dir.Y();
        dirZAvg+=dir.Z();
        fTPx.push_back(loc.X());
        fTPy.push_back(loc.Y());
        fTPz.push_back(loc.Z());
        hx.push_back(loc.X());
        hy.push_back(loc.Y());
        hz.push_back(loc.Z());
        hi.push_back(hits.at(j)->Integral());        
        //std::cout<<"----> Position X "<<loc.X()<<" Y "<<loc.Y()<<" Z "<<loc.Z()<<std::endl;
        //std::cout<<"----> Direction dirX "<<dir.X()<<" dirY "<<dir.Y()<<" dirZ "<<dir.Z()<<std::endl;
        gCounts++;
      }
      if(tpcTrack.Length()>30){
        icarus::crt::triplematching::TrackBarycenter TrackBarycenter = icarus::crt::triplematching::GetTrackBarycenter(hx, hy, hz, hi);
        for(const auto& crtpmtM : crtpmtMatches){
          if(cryo==0 && crtpmtM.flashPosition.X()>0) continue;
          else if(cryo==1 && crtpmtM.flashPosition.X()<0) continue;
          std::cout<<"Flash Time "<<crtpmtM.flashTime<<" Flash Type "<<(int)crtpmtM.flashClassification<<" Position X "<<crtpmtM.flashPosition.X()<<" Y "<<crtpmtM.flashPosition.Y()<<" Z "<<crtpmtM.flashPosition.Z()<<std::endl;
          std::cout<<"Delta Z "<<abs(TrackBarycenter.BarZ-crtpmtM.flashPosition.Z())<<std::endl;
          if(abs(TrackBarycenter.BarZ-crtpmtM.flashPosition.Z())<30){
            icarus::crt::triplematching::DriftTrack(&hits, crtpmtM.flashTime,cryo);
          }
        }
      }
      fDirXAvg=dirXAvg/gCounts;
      fDirYAvg=dirYAvg/gCounts;
      fDirZAvg=dirZAvg/gCounts;
      fIDTrack=thisTrackID;
      fCryo=cryo;
      fMatchTree->Fill();
      ClearVecs();
      //if (hits.size() == 0) continue;
      
    }
    
  }

  for (art::InputTag const& flashLabel : fFlashLabels) {
    auto const flashHandle =
        e.getHandle<std::vector<recob::OpFlash>>(flashLabel);
    art::FindMany<recob::OpHit> findManyHits(flashHandle, e, flashLabel);

    for (auto const& [iflash, flash] : util::enumerate(*flashHandle)) {
      //double tflash = flash.Time();
      //double tAbsflash = flash.AbsTime();
      vector<recob::OpHit const*> const& hits = findManyHits.at(iflash);
      //int nPMTsTriggering = 0;
      double firstStartTime = 999999, firstPeakTime = 999999, firstRiseTime = 999999;
      geo::vect::MiddlePointAccumulator flashCentroid;
      // double flash_pos[3]={0,0,0};
      // double ampsum = 0, t_m = 0; // unused
      for (auto const& hit : hits) {
        if (firstStartTime > hit->StartTime()) firstStartTime = hit->StartTime();
        if (firstPeakTime > hit->PeakTime()) firstPeakTime = hit->PeakTime();
        if (firstRiseTime > hit->StartTime()+hit->RiseTime()) firstRiseTime = hit->StartTime()+hit->RiseTime();
        geo::Point_t const pos =
            fGeometryService->OpDetGeoFromOpChannel(hit->OpChannel())
                .GetCenter();
        double amp = hit->Amplitude();
        flashCentroid.add(pos, amp);
        // t_m = t_m + hit->StartTime(); // unused
      }
      //geo::Point_t flash_pos = flashCentroid.middlePoint();
      //fMatchTree->Fill();
      ClearVecs();
    }  // for Flash
  }
}

void icarus::crt::TripleMatchingAna::ClearVecs() {
  // matchTree
  fTPx.clear();
  fTPy.clear();
  fTPz.clear();
}

DEFINE_ART_MODULE(icarus::crt::TripleMatchingAna)
