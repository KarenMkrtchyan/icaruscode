////////////////////////////////////////////////////////////////////////
// Class:       TripleMatchingAna
// Plugin Type: analyzer (Unknown Unknown)
// File:        TripleMatchingAna_module.cc
//
// Generated by Francesco Poppi on May 02 2024
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art_root_io/TFileService.h"
#include "canvas/Persistency/Common/FindMany.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

// LArSoft includes
#include "larcore/CoreUtils/ServiceUtil.h"
#include "larcore/Geometry/Geometry.h"
#include "larcorealg/Geometry/GeometryCore.h"
#include "lardata/DetectorInfoServices/DetectorClocksService.h"
#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/AnalysisBase/T0.h"
#include "lardataobj/RecoBase/PFParticleMetadata.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/TrackHitMeta.h"

// Data product includes
#include "icaruscode/CRT/CRTUtils/CRTBackTracker.h"
#include "icaruscode/CRT/CRTUtils/CRTCommonUtils.h"
#include "icaruscode/Decode/DataProducts/TriggerConfiguration.h"
#include "larcorealg/CoreUtils/enumerate.h"
#include "lardataobj/RecoBase/OpFlash.h"
#include "lardataobj/RecoBase/OpHit.h"
#include "nusimdata/SimulationBase/MCGeneratorInfo.h"
#include "nusimdata/SimulationBase/MCParticle.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "sbnobj/Common/CRT/CRTHit.hh"
#include "sbnobj/Common/CRT/CRTTrack.hh"
#include "sbnobj/Common/Trigger/ExtraTriggerInfo.h"
// C++ includes
#include <map>
#include <numeric>
#include <vector>
#include <optional>

// ROOT includes
#include "TTree.h"
#include "TVector3.h"

using std::map;
using std::vector;

namespace icarus {
namespace crt {
class TripleMatchingAna;


}  // namespace crt
}  // namespace icarus

using namespace icarus::crt;

class icarus::crt::TripleMatchingAna : public art::EDAnalyzer {
 public:
  using CRTHit = sbn::crt::CRTHit;

  explicit TripleMatchingAna(fhicl::ParameterSet const& p);
  // The compiler-generated destructor is fine for non-base
  // classes without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  TripleMatchingAna(TripleMatchingAna const&) = delete;
  TripleMatchingAna(TripleMatchingAna&&) = delete;
  TripleMatchingAna& operator=(TripleMatchingAna const&) = delete;
  TripleMatchingAna& operator=(TripleMatchingAna&&) = delete;

  // Required functions.
  void beginRun(art::Run const& r) override;
  void analyze(art::Event const& e) override;

 private:
  // Declare member data here.

  void ClearVecs();

  // art::InputTag fOpHitModuleLabel;
  art::InputTag fOpFlashModuleLabel0;
  art::InputTag fOpFlashModuleLabel1;
  art::InputTag fOpFlashModuleLabel2;
  art::InputTag fOpFlashModuleLabel3;
  art::InputTag fCrtHitModuleLabel;
  art::InputTag fTriggerLabel;
  art::InputTag fTriggerConfigurationLabel;
  // tart::InputTag fCrtTrackModuleLabel;
  std::vector<art::InputTag> fTPCTrackLabel; ///< labels for source of tracks
  std::vector<art::InputTag> fPFParticleLabel; ///< labels for source of PFParticle
  
  std::optional<icarus::TriggerConfiguration> fTriggerConfiguration;

  int fEvent;   ///< number of the event being processed
  int fRun;     ///< number of the run being processed
  int fSubRun;  ///< number of the sub-run being processed
  double fTrackLength; ///< track length
  double fTrackStartX; ///< track startX
  double fTrackStartY; ///< track startY
  double fTrackStartZ; ///< track startZ
  double fTrackEndX; ///< track endX
  double fTrackEndY; ///< track endY
  double fTrackEndZ; ///< track endZ
  double fTrackScore; ///< track score
  double fNuScore; ///< nu score
  double fClearCosmic; ///< clear cosmic
  int fSizeHits; ///< nhits of the Tracks
  double fT0Track; ///< time of the Tracks
  double fDirStartx; ///< dirx of Start
  double fDirStarty; ///< diry of Start
  double fDirStartz; ///< dirz of Start
  double fDirEndx; ///< endx of Start
  double fDirEndy; ///< endy of Start
  double fDirEndz; ///< endz of Start
  double fDirXAvg;
  double fDirYAvg;
  double fDirZAvg;
  std::vector<float> fTPx;
  std::vector<float> fTPy;
  std::vector<float> fTPz;
  int fIDTrack;
  int fCryo;

  // add trigger data product vars
  unsigned int m_gate_type;
  std::string m_gate_name;
  uint64_t m_trigger_timestamp;
  uint64_t m_gate_start_timestamp;
  uint64_t m_trigger_gate_diff;
  // uint64_t m_gate_crt_diff;
  uint64_t m_gate_width;

  //  CRTBackTracker* bt;
  CRTCommonUtils* crtutil;

  std::vector<art::InputTag> fFlashLabels;

  TTree* fMatchTree;

  // matchTree vars

  geo::GeometryCore const* fGeometryService;  ///< pointer to Geometry provider
};

icarus::crt::TripleMatchingAna::TripleMatchingAna(fhicl::ParameterSet const& p)
    : EDAnalyzer{p}  // ,
      //,fOpHitModuleLabel(p.get<art::InputTag>("OpHitModuleLabel","ophit"))
      ,
      fOpFlashModuleLabel0(
          p.get<art::InputTag>("OpFlashModuleLabel0")),
      fOpFlashModuleLabel1(
          p.get<art::InputTag>("OpFlashModuleLabel1")),
      fCrtHitModuleLabel(p.get<art::InputTag>("CrtHitModuleLabel", "crthit")),
      fTriggerLabel(p.get<art::InputTag>("TriggerLabel", "daqTrigger")),
      fTriggerConfigurationLabel(
          p.get<art::InputTag>("TriggerConfiguration", "triggerconfig")),
      fTPCTrackLabel(p.get< std::vector<art::InputTag> >("TPCTrackLabel",             {""})),
      fPFParticleLabel(p.get< std::vector<art::InputTag> >("PFParticleLabel",             {""})),  
      crtutil(new CRTCommonUtils())
// More initializers here.
{
  // Call appropriate consumes<>() for any products to be retrieved by this
  // module.
  fFlashLabels.push_back(fOpFlashModuleLabel0);
  fFlashLabels.push_back(fOpFlashModuleLabel1);

  // Get a pointer to the geometry service provider.
  fGeometryService = lar::providerFrom<geo::Geometry>();

  art::ServiceHandle<art::TFileService> tfs;

  fMatchTree =
      tfs->make<TTree>("matchTree", "CRTHit - OpHit/Flash matching analysis");

  fMatchTree->Branch("event", &fEvent, "event/I");
  fMatchTree->Branch("run", &fRun, "run/I");
  fMatchTree->Branch("subrun", &fSubRun, "subrun/I");
  fMatchTree->Branch("track_length", &fTrackLength);
  fMatchTree->Branch("track_startX", &fTrackStartX);
  fMatchTree->Branch("track_startY", &fTrackStartY);
  fMatchTree->Branch("track_startZ", &fTrackStartZ);
  fMatchTree->Branch("track_endX", &fTrackEndX);
  fMatchTree->Branch("track_endY", &fTrackEndY);
  fMatchTree->Branch("track_endZ", &fTrackEndZ);
  fMatchTree->Branch("TrackScore", &fTrackScore);
  fMatchTree->Branch("NuScore", &fNuScore);
  fMatchTree->Branch("ClearCosmic", &fClearCosmic);
  fMatchTree->Branch("nHits", &fSizeHits);
  fMatchTree->Branch("T0", &fT0Track);
  fMatchTree->Branch("dirXAvg", &fDirXAvg);
  fMatchTree->Branch("dirYAvg", &fDirYAvg);
  fMatchTree->Branch("dirZAvg", &fDirZAvg);
  fMatchTree->Branch("TrackID", &fIDTrack);
  fMatchTree->Branch("TPX", &fTPx);
  fMatchTree->Branch("TPY", &fTPy);
  fMatchTree->Branch("TPZ", &fTPz);
  fMatchTree->Branch("cryo", &fCryo);

}


void icarus::crt::TripleMatchingAna::beginRun(art::Run const& r) {
  
  // we don't know if this is data or not; if not, there will be no trigger config
  auto const& trigConfHandle = 
    r.getHandle<icarus::TriggerConfiguration>(fTriggerConfigurationLabel);
  
  fTriggerConfiguration
    = trigConfHandle.isValid()? std::make_optional(*trigConfHandle): std::nullopt;

}


void icarus::crt::TripleMatchingAna::analyze(art::Event const& e) {
  // Implementation of required member function here.
  
  if (!fTriggerConfiguration) {
    mf::LogDebug("TripleMatchingAna")
      << "Skipping because no data (or at least no trigger configuration).";
    return;
  }
  
  mf::LogDebug("TripleMatchingAna: ") << "beginning analyis" << '\n';
  // Start by fetching some basic event information for our n-tuple.
  fEvent = e.id().event();
  fRun = e.run();
  fSubRun = e.subRun();
  ClearVecs();

  // add trigger info
  if (!fTriggerLabel.empty()) {
    art::Handle<sbn::ExtraTriggerInfo> trigger_handle;
    e.getByLabel(fTriggerLabel, trigger_handle);
    if (trigger_handle.isValid()) {
      sbn::triggerSource bit = trigger_handle->sourceType;
      m_gate_type = (unsigned int)bit;
      m_gate_name = bitName(bit);
      m_trigger_timestamp = trigger_handle->triggerTimestamp;
      m_gate_start_timestamp = trigger_handle->beamGateTimestamp;
      m_trigger_gate_diff =
          trigger_handle->triggerTimestamp - trigger_handle->beamGateTimestamp;
      // Read Beam Gate Size
      m_gate_width = fTriggerConfiguration->getGateWidth(m_gate_type);
    } else {
      mf::LogError("TripleMatchingAna:")
          << "No sbn::ExtraTriggerInfo associated to label: "
          << fTriggerLabel.encode() << "\n";
    }
  } else {
    // std::cout  << "Trigger Data product " << fTriggerLabel.label() << " not
    // found!\n" ;
  }

  // OpFlash
  std::array<art::Handle<std::vector<recob::OpFlash>>, 2U> flashHandles;
  for (int i = 0; i < 2; i++) {
    flashHandles[i] = e.getHandle<std::vector<recob::OpFlash>>(fFlashLabels[i]);
  }

  // CRTHits
  art::Handle<std::vector<CRTHit>> crtHitListHandle;
  std::vector<art::Ptr<CRTHit>> crtHitList;
  if (e.getByLabel(fCrtHitModuleLabel, crtHitListHandle))
    art::fill_ptr_vector(crtHitList, crtHitListHandle);

  // fNCrt = crtHitList.size();

  // Tracks
  int cryo=-1;
  int thisTrackID=-1;
  for(const auto& trackLabel : fTPCTrackLabel) {
    cryo++;
    auto it = &trackLabel - fTPCTrackLabel.data();
    // Get reconstructed tracks from the event    
    auto tpcTrackHandle = e.getValidHandle<std::vector<recob::Track>>(trackLabel);
    if (!tpcTrackHandle.isValid()) continue;

    //Get PFParticles
    auto pfpListHandle = e.getValidHandle<std::vector<recob::PFParticle> >(fPFParticleLabel[it]);
    if (!pfpListHandle.isValid()) continue;

    //Get PFParticle-Track association
    art::FindManyP<recob::PFParticle> fmpfp(tpcTrackHandle, e, trackLabel); 

    //Get T0-PFParticle association
    art::FindManyP<anab::T0> fmt0pandora(pfpListHandle, e, fPFParticleLabel[it]);
    art::FindManyP<larpandoraobj::PFParticleMetadata> PFPMetaDataAssoc(pfpListHandle, e, fPFParticleLabel[it]);
    art::FindManyP<recob::Hit> findManyHits(tpcTrackHandle, e, trackLabel);
    art::FindManyP<recob::Hit, recob::TrackHitMeta> fmtrkHits(tpcTrackHandle, e, trackLabel);

    std::cout<<"Label "<<trackLabel<<std::endl;
    for (auto const& tpcTrack : (*tpcTrackHandle)){
      thisTrackID++;
      //std::cout<<"Type of tpcTrack "<<typeid(tpcTrack).name()<<std::endl;
      std::cout<<"This Track is long "<<tpcTrack.Length()<<std::endl;
      std::cout<<"This Track start "<<tpcTrack.Start().X()<<" "<<tpcTrack.Start().Y()<<" "<<tpcTrack.Start().Z()<<std::endl;
      std::cout<<"This Track end "<<tpcTrack.End().X()<<" "<<tpcTrack.End().Y()<<" "<<tpcTrack.End().Z()<<std::endl;
      fTrackLength=tpcTrack.Length();
      fTrackStartX=tpcTrack.Start().X();
      fTrackStartY=tpcTrack.Start().Y();
      fTrackStartZ=tpcTrack.Start().Z();
      fTrackEndX=tpcTrack.End().X();
      fTrackEndY=tpcTrack.End().Y();
      fTrackEndZ=tpcTrack.End().Z();
      
	    //auto idx = &tpcTrack - (*tpcTrackHandle).data();
      double t0 = -999999999;
	    //Find PFParticle for track i
	    //art::Ptr::key() gives the index in the vector 
	    auto pfps = fmpfp.at(tpcTrack.ID());
	    if (!pfps.empty()){
	      //Find T0 for PFParticle
	      auto t0s = fmt0pandora.at(pfps[0].key()); 
	      if (!t0s.empty()){  
	        t0 = t0s[0]->Time();   //Get T0  
          std::cout<<"The Slice is not empty, size "<<pfps.size()<<std::endl;
	      }
        auto const pfpmeta = PFPMetaDataAssoc.at(pfps[0].key());
        //std::cout<<"Type of pfpmeta "<<typeid(pfpmeta[0]).name()<<std::endl;
        auto const &propertiesMap (pfpmeta[0]->GetPropertiesMap());
        auto const &pfpTrackScoreIter(propertiesMap.find("TrackScore"));
        double trackScore = (pfpTrackScoreIter == propertiesMap.end()) ? -5.f : pfpTrackScoreIter->second;
        auto const &pfpNuScoreIter(propertiesMap.find("NuScore"));
        double nuScore = (pfpNuScoreIter == propertiesMap.end()) ? -5.f : pfpNuScoreIter->second;
        auto const &pfpIsClearCosmicScoreIter(propertiesMap.find("IsClearCosmic"));
        double isClearCosmic = (pfpIsClearCosmicScoreIter == propertiesMap.end()) ? -5.f : pfpIsClearCosmicScoreIter->second;
        std::cout<<"Track Score "<<trackScore<<" ; NuScore "<<nuScore<<" ; isClearCosmic "<<isClearCosmic<<std::endl;
        fTrackScore=trackScore;
        fNuScore=nuScore;
        fClearCosmic=isClearCosmic;
      }
      //std::cout<<"Type of pfps "<<typeid(pfps).name()<<std::endl;
      std::vector<art::Ptr<recob::Hit>> hits = findManyHits.at(tpcTrack.ID());
      const std::vector<const recob::TrackHitMeta*> hitsmeta=fmtrkHits.data(tpcTrack.ID());
	    std::cout<< "This Track has hits "<<hits.size()<<" and meta size "<<hitsmeta.size()<<" entries and T0: " <<  (Long64_t) t0 << std::endl;
      fSizeHits=hits.size();
      fT0Track=t0;
      double dirXAvg=0, dirYAvg=0, dirZAvg=0;
      int gCounts=0;
      for(size_t j=0; j<hits.size(); j++){
        std::cout<<"Hit number "<<j<<" integral "<<hits.at(j)->Integral()<<" time "<<hits.at(j)->PeakTime()<<" plane "<<hits.at(j)->WireID().Plane<<" TPC "<<hits.at(j)->WireID().TPC<<std::endl;
        geo::Point_t loc = tpcTrack.LocationAtPoint(j);
        geo::Vector_t dir = tpcTrack.DirectionAtPoint(j);
        if(loc.X()==-999) continue;
        dirXAvg+=dir.X();
        dirYAvg+=dir.Y();
        dirZAvg+=dir.Z();
        fTPx.push_back(loc.X());
        fTPy.push_back(loc.Y());
        fTPz.push_back(loc.Z());
        
        std::cout<<"----> Position X "<<loc.X()<<" Y "<<loc.Y()<<" Z "<<loc.Z()<<std::endl;
        std::cout<<"----> Direction dirX "<<dir.X()<<" dirY "<<dir.Y()<<" dirZ "<<dir.Z()<<std::endl;
        gCounts++;
      }
      fDirXAvg=dirXAvg/gCounts;
      fDirYAvg=dirYAvg/gCounts;
      fDirZAvg=dirZAvg/gCounts;
      fIDTrack=thisTrackID;
      fCryo=Cryo;
      fMatchTree->Fill();
      ClearVecs();
      //if (hits.size() == 0) continue;
      
    }
    
  }

  for (art::InputTag const& flashLabel : fFlashLabels) {
    auto const flashHandle =
        e.getHandle<std::vector<recob::OpFlash>>(flashLabel);
    art::FindMany<recob::OpHit> findManyHits(flashHandle, e, flashLabel);

    for (auto const& [iflash, flash] : util::enumerate(*flashHandle)) {
      //double tflash = flash.Time();
      //double tAbsflash = flash.AbsTime();
      vector<recob::OpHit const*> const& hits = findManyHits.at(iflash);
      //int nPMTsTriggering = 0;
      double firstStartTime = 999999, firstPeakTime = 999999, firstRiseTime = 999999;
      geo::vect::MiddlePointAccumulator flashCentroid;
      // double flash_pos[3]={0,0,0};
      // double ampsum = 0, t_m = 0; // unused
      for (auto const& hit : hits) {
        if (firstStartTime > hit->StartTime()) firstStartTime = hit->StartTime();
        if (firstPeakTime > hit->PeakTime()) firstPeakTime = hit->PeakTime();
        if (firstRiseTime > hit->StartTime()+hit->RiseTime()) firstRiseTime = hit->StartTime()+hit->RiseTime();
        geo::Point_t const pos =
            fGeometryService->OpDetGeoFromOpChannel(hit->OpChannel())
                .GetCenter();
        double amp = hit->Amplitude();
        flashCentroid.add(pos, amp);
        // t_m = t_m + hit->StartTime(); // unused
      }
      //geo::Point_t flash_pos = flashCentroid.middlePoint();
      //fMatchTree->Fill();
      ClearVecs();
    }  // for Flash
  }
}

void icarus::crt::TripleMatchingAna::ClearVecs() {
  // matchTree
  fTPx.clear();
  fTPy.clear();
  fTPz.clear();
}

DEFINE_ART_MODULE(icarus::crt::TripleMatchingAna)
