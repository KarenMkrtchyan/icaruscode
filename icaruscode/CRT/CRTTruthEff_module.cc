/////////////////////////////////////////////////////////////////////////////
/// Class:       CRTTruthEff
/// Module Type: analyzer
/// File:        CRTTruthEff_module.cc
///
/// Author:         Tyler Boone
/// E-mail address: tboone@FNAL.gov
///
/// Modified from CRTT0Matching_module by Tyler Boone
/////////////////////////////////////////////////////////////////////////////

// sbndcode includes
#include "sbnobj/Common/CRT/CRTHit.hh"
#include "icaruscode/IcarusObj/CRTTPCMatchingInfo.h"
#include "icaruscode/CRT/CRTUtils/CRTT0MatchAlg.h"
#include "icaruscode/CRT/CRTUtils/CRTBackTracker.h"
#include "icaruscode/CRT/CRTUtils/RecoUtils.h"

// Framework includes
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "canvas/Persistency/Common/FindOneP.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Event.h" 
#include "canvas/Persistency/Common/Ptr.h" 
#include "canvas/Persistency/Common/PtrVector.h" 
#include "art/Persistency/Common/PtrMaker.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art_root_io/TFileService.h"
#include "art_root_io/TFileDirectory.h"

#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>
#include <iostream>
#include <map>
#include <iterator>
#include <algorithm>

// LArSoft
#include "larcore/Geometry/Geometry.h"
#include "larcorealg/Geometry/GeometryCore.h"
#include "larcorealg/Geometry/PlaneGeo.h"
#include "larcorealg/Geometry/WireGeo.h"
#include "lardataobj/AnalysisBase/T0.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/Track.h"
#include "larcore/CoreUtils/ServiceUtil.h" // lar::providerFrom()
#include "lardata/DetectorInfoServices/LArPropertiesService.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "lardataobj/RawData/ExternalTrigger.h"
#include "larcoreobj/SimpleTypesAndConstants/PhysicalConstants.h"
#include "lardataobj/AnalysisBase/ParticleID.h"
#include "larsim/MCCheater/BackTrackerService.h"
#include "sbnobj/Common/Trigger/ExtraTriggerInfo.h"
#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/AnalysisBase/T0.h"
#include "lardataobj/RecoBase/PFParticleMetadata.h"
#include "larcorealg/CoreUtils/zip.h"
#include "larcorealg/CoreUtils/enumerate.h"
#include "larreco/RecoAlg/Cluster3DAlgs/Cluster3D.h"
#include "larsim/MCCheater/ParticleInventoryService.h"

// ROOT
#include "TVector3.h"
#include "TH1.h"
#include "TH2.h"
#include "TVector3.h"
#include "TTree.h"
//Eigen includes (for PCA analysis)
#include "Eigen/Core"
#include "Eigen/Dense"
#include "Eigen/Eigenvalues"
#include "Eigen/Geometry"
#include "Eigen/Jacobi"
#include <string_view>


namespace icarus {
  
  class CRTTruthEff : public art::EDAnalyzer {
  public:

    explicit CRTTruthEff(fhicl::ParameterSet const & p);

    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.

    // Plugins should not be copied or assigned.
    CRTTruthEff(CRTTruthEff const &) = delete;
    CRTTruthEff(CRTTruthEff &&) = delete;
    CRTTruthEff & operator = (CRTTruthEff const &) = delete; 
    CRTTruthEff & operator = (CRTTruthEff &&) = delete;

    // Required functions.
    void analyze(const art::Event & e) override;

    // Selected optional functions.
    void beginJob() override;

//    void reconfigure(fhicl::ParameterSet const & p);
 
    void GetAncestorID(int trueid, int &motherid, int &ancestorid, int &layers, std::map<int, simb::MCParticle> all_particles);
    void getCatCrossXYZ(recob::Track trk, double &my_x, double &my_y, double &my_z);
    void getTickRange(std::vector<art::Ptr<recob::Hit>> hits, int &mintick, int &maxtick);
    void findIntersectingCRTVolume(TVector3 &retvec, TVector3 &endpoint, int &likely_CRT_region1, int &likely_CRT_region2, int &likely_CRT_region3);
    void pointChecker(recob::Track trk, bool &startisinTPC, bool &endisinTPC, int &startflag, int &endflag);
    void endpoint_PCA_ana(recob::Track trk, bool usestartpt, TVector3 &bestfit_dir, TVector3 &bestfit_pos);
    float vect_dist(TVector3 vec1, TVector3 vec2);
    bool willEnterCRTVolume(TVector3 vecpos, TVector3 vecdir, int crtregion);
    double getnewDCA(TVector3 CRTHitpos, TVector3 TPC_posvec, TVector3 TPC_dirvec);
    double CRT_plane_dist(TVector3 TPC_track_pos, TVector3 TPC_track_dir, TVector3 CRT_hit_pos, int plane_axis/*0 for x, 1 for y, 2 for z*/);
    bool crosses_CRT(TVector3 pos1, TVector3 pos2, int crtregion, double &crossx, double &crossy, double &crossz);
    bool crosses_TPC(TVector3 pos1, TVector3 pos2, double &crossx, double &crossy, double &crossz);
    int CRT_region_code(std::string reg);

  private:
    art::ServiceHandle<art::TFileService> tfs;
    icarus::crt::CRTBackTracker bt;

    // Params got from fcl file.......
    //    art::InputTag fTpcTrackModuleLabel; 	     ///< name of track producer
    std::vector<art::InputTag> fTpcTrackModuleLabel; ///< name of track producer
    std::vector<art::InputTag> fPFParticleLabel;     ///< labels for source of PFParticle
    art::InputTag              fCrtHitModuleLabel;   ///< name of crt producer
    art::InputTag              fTriggerLabel;        ///< labels for trigger
    art::InputTag 	       fSimModuleLabel;      ///< name of detsim producer
    art::InputTag	       fMCParticleLabel;     ///<label for MCParticles
    art::ServiceHandle<cheat::ParticleInventoryService > partInventory;
    CRTT0MatchAlg              t0Alg;		     ///< used to call matching functions
    bool                       fVerbose;       	     ///< print information about what's going on
    bool		       fIsData;              ///< switch for if this is data or MC
    bool	tpcEast, tpcWest;//true if in that TPC, false otherwise

    geo::GeometryCore const* fGeometryService;   ///< pointer to Geometry provider
    icarus::crt::CRTCommonUtils* fCrtutils;
    //  CRTCommonUtils* fCrtutils;

	TTree* tr_mcparticle;
	int fEvent;        					///< Event number
	int fRun;          					///< Run number
	int fSubRun;       					///< SubRun number
	int mcp_TrackID;					///< MCParticle TrackID
	int mcp_PDG;						///< MCParticle PDG code
	int mcp_Mother;						///< MCParticle Mother
	int mcp_NumDaughters;					///< MCParticle Daughter

	double mcp_start_x, mcp_start_y, mcp_start_z; 		///< MCParticle start (X,Y,Z)
	double mcp_end_x, mcp_end_y, mcp_end_z; 		///< MCParticle end (X,Y,Z)
	double mcp_start_px, mcp_start_py, mcp_start_pz;
	double mcp_start_t, mcp_start_E;
	float mcp_track_length;					///< MCParticle track length: calculate lengths between positions and add them up for this number

	double mcp_tpccross_x, mcp_tpccross_y, mcp_tpccross_z; ///< really just looks for MCParticle position when it crosses the Y=134.96cm plane

	int mcp_posvec_size;					///< MCParticle size of position vector
	std::vector<double> mcp_x, mcp_y, mcp_z, mcp_t;		///< MCParticle positions in vector form as well as timestamp

	std::vector<double> mcp_energy, mcp_px, mcp_py, mcp_pz; ///< MCParticle momenta and energy along track in vector form

	int num_crt_hits;
	std::vector<double> crt_x, crt_y, crt_z, crt_t;		///< CRT Hits in the event (X,Y,Z,T) info
	std::vector<int> crt_region, crt_trueID, crt_PDG;	///< Region code of CRTHit
	std::vector<float> crt_mcp_dist;			///< Distance of Closest Approach between MCParticle and given CRT Hit

	int num_crtcross;							///< number of times the track crossed a CRT region
	std::vector<double> mcp_crtcross_x, mcp_crtcross_y, mcp_crtcross_z;	///< Position where MCParticle first crosses a CRT volume
	std::vector<double> mcp_crtcross_region;				///< CRT Region that is being crossed

	    //add trigger data product vars
	    unsigned int m_gate_type;
	    std::string  m_gate_name;
	    uint64_t     m_trigger_timestamp;
	    uint64_t     m_gate_start_timestamp;
	    uint64_t     m_trigger_gate_diff;
	//    uint64_t     m_gate_crt_diff;

	  }; // class CRTTruthEff


	  CRTTruthEff::CRTTruthEff(fhicl::ParameterSet const & p)
	    : EDAnalyzer(p), t0Alg(p.get<fhicl::ParameterSet>("T0Alg"))
	    , fCrtutils(new icarus::crt::CRTCommonUtils())
	      // Initialize member data here, if know don't want to reconfigure on the fly
	  {

	    // Call appropriate produces<>() functions here.
	//    produces< std::vector<anab::T0>                                              >();
	//    produces< art::Assns<recob::Track , anab::T0, icarus::CRTTPCMatchingInfo>    >();
	//    produces< art::Assns<sbn::crt::CRTHit, anab::T0, icarus::CRTTPCMatchingInfo> >();

    fGeometryService = lar::providerFrom<geo::Geometry>();
    fCrtHitModuleLabel   = p.get<art::InputTag> ("CrtHitModuleLabel", "crthit"); 
    fPFParticleLabel    =  p.get< std::vector<art::InputTag> >("PFParticleLabel",             {""});

    fIsData = p.get<bool>("IsData");
    if(fIsData) fTriggerLabel        = p.get<art::InputTag>("TriggerLabel","daqTrigger");
    
    fVerbose = p.get<bool>("Verbose");
    bt = icarus::crt::CRTBackTracker{ p.get<fhicl::ParameterSet>("CRTBackTrack") };
    fSimModuleLabel = p.get<art::InputTag>("SimChannelModuleLabel","daq:simpleSC");
    fMCParticleLabel = p.get<art::InputTag>("MCParticleLabel","largeant");

  } // CRTTruthEff()

void CRTTruthEff::beginJob(){

    	// Access tfileservice to handle creating and writing histograms
    	art::ServiceHandle<art::TFileService> tfs;

	tr_mcparticle = tfs->make<TTree>("CRT_Truth","CRT+Truth information by event");
	tr_mcparticle->Branch("fEvent",&fEvent,"fEvent/I");
    	tr_mcparticle->Branch("fRun",&fRun,"fRun/I");
    	tr_mcparticle->Branch("fSubRun",&fSubRun,"fSubRun/I");
	tr_mcparticle->Branch("mcp_TrackID",&mcp_TrackID,"mcp_TrackID/I");
	tr_mcparticle->Branch("mcp_PDG",&mcp_PDG,"mcp_PDG/I");
	tr_mcparticle->Branch("mcp_Mother",&mcp_Mother,"mcp_Mother/I");
	tr_mcparticle->Branch("mcp_NumDaughters",&mcp_NumDaughters,"mcp_NumDaughters/I");
	tr_mcparticle->Branch("mcp_start_x",&mcp_start_x,"mcp_start_x/D");
	tr_mcparticle->Branch("mcp_start_y",&mcp_start_y,"mcp_start_y/D");
	tr_mcparticle->Branch("mcp_start_z",&mcp_start_z,"mcp_start_z/D");
	tr_mcparticle->Branch("mcp_start_px",&mcp_start_px,"mcp_start_px/D");
	tr_mcparticle->Branch("mcp_start_py",&mcp_start_py,"mcp_start_py/D");
	tr_mcparticle->Branch("mcp_start_pz",&mcp_start_pz,"mcp_start_pz/D");
	tr_mcparticle->Branch("mcp_start_t",&mcp_start_t,"mcp_start_t/D");
	tr_mcparticle->Branch("mcp_start_E",&mcp_start_E,"mcp_start_E/D");
	tr_mcparticle->Branch("mcp_end_x",&mcp_end_x,"mcp_end_x/D");
	tr_mcparticle->Branch("mcp_end_y",&mcp_end_y,"mcp_end_y/D");
	tr_mcparticle->Branch("mcp_end_z",&mcp_end_z,"mcp_end_z/D");
	tr_mcparticle->Branch("mcp_track_length",&mcp_track_length,"mcp_track_length/F");
	tr_mcparticle->Branch("mcp_posvec_size",&mcp_posvec_size,"mcp_posvec_size/I");
	tr_mcparticle->Branch("num_crtcross",&num_crtcross,"num_crtcross/I");
	tr_mcparticle->Branch("mcp_crtcross_x",&mcp_crtcross_x);
	tr_mcparticle->Branch("mcp_crtcross_y",&mcp_crtcross_y);
	tr_mcparticle->Branch("mcp_crtcross_z",&mcp_crtcross_z);
	tr_mcparticle->Branch("mcp_crtcross_region",&mcp_crtcross_region);
	tr_mcparticle->Branch("mcp_x",&mcp_x);
	tr_mcparticle->Branch("mcp_y",&mcp_y);
	tr_mcparticle->Branch("mcp_z",&mcp_z);
	tr_mcparticle->Branch("mcp_px",&mcp_px);
	tr_mcparticle->Branch("mcp_py",&mcp_py);
	tr_mcparticle->Branch("mcp_pz",&mcp_pz);
	tr_mcparticle->Branch("mcp_t",&mcp_t);
	tr_mcparticle->Branch("mcp_energy",&mcp_energy);
	tr_mcparticle->Branch("num_crt_hits",&num_crt_hits,"num_crt_hits/I");
	tr_mcparticle->Branch("crt_x",&crt_x);
	tr_mcparticle->Branch("crt_y",&crt_y);
	tr_mcparticle->Branch("crt_z",&crt_z);
	tr_mcparticle->Branch("crt_t",&crt_t);
	tr_mcparticle->Branch("crt_trueID",&crt_trueID);
	tr_mcparticle->Branch("crt_PDG",&crt_PDG);
	tr_mcparticle->Branch("crt_region",&crt_region);
	tr_mcparticle->Branch("crt_mcp_dist",&crt_mcp_dist);
	tr_mcparticle->Branch("mcp_tpccross_x",&mcp_crtcross_x);
	tr_mcparticle->Branch("mcp_tpccross_y",&mcp_crtcross_y);
	tr_mcparticle->Branch("mcp_tpccross_z",&mcp_crtcross_z);

} // CRTTruthEff::beginJob()

void CRTTruthEff::analyze(const art::Event & event){

	fIsData = event.isRealData();

    	auto const& crtHits = event.getProduct<std::vector<sbn::crt::CRTHit>>(fCrtHitModuleLabel);
//  	auto const clockData = art::ServiceHandle<detinfo::DetectorClocksService const>()->DataFor(event);

	std::map<int, simb::MCParticle> particles;

	// Loop over the true particles
   	bt.Initialize(event);
    	auto particleHandle = event.getValidHandle<std::vector<simb::MCParticle>>(fMCParticleLabel);

	for (auto const& particle: (*particleHandle)){
              	// Make map with ID
              	int partID = particle.TrackId();
		particles[partID] = particle;
	}//end loop over particles in particleHandle

//	auto const& MCParticle_vec(*particleHandle);
    	for (auto const& particle: (*particleHandle)){

		//Begin with variable initialization+clearing vectors to avoid erroneous entries in the TTree
		fEvent = -99999; fRun = -99999; fSubRun = -99999;
		mcp_TrackID = -99999; mcp_PDG = -99999; mcp_Mother = -99999; mcp_NumDaughters = -99999;
		mcp_start_x = -99999; mcp_end_x = -99999; mcp_start_y = -99999; mcp_end_y = -99999; mcp_start_z = -99999; mcp_end_z = -99999;
		mcp_start_px = -99999; mcp_start_py = -99999; mcp_start_pz = -99999;
		mcp_start_t = -99999; mcp_start_E = -99999;
		mcp_tpccross_x = -99999; mcp_tpccross_y = -99999; mcp_tpccross_z = -99999;
		mcp_track_length = -99999; mcp_posvec_size = -99999; num_crt_hits = 0;
		num_crtcross = 0;

		mcp_crtcross_x.clear(); mcp_crtcross_y.clear(); mcp_crtcross_z.clear(); mcp_crtcross_region.clear();
		mcp_x.clear(); mcp_y.clear(); mcp_z.clear(); mcp_t.clear(); mcp_energy.clear(); mcp_px.clear(); mcp_py.clear(); mcp_pz.clear();
		crt_x.clear(); crt_y.clear(); crt_z.clear(); crt_t.clear(); crt_mcp_dist.clear(); crt_region.clear();
		crt_trueID.clear(); crt_PDG.clear();

		//Get the easy stuff out of the way
		fEvent  = event.id().event();
		fRun    = event.run();
		fSubRun = event.subRun();

        	mcp_TrackID = particle.TrackId();
		mcp_PDG     = particle.PdgCode();
		mcp_Mother  = particle.Mother();
		mcp_NumDaughters= particle.NumberDaughters();

//	      	particles[mcp_TrackID] = particle;

		for(auto &crtHit : crtHits){

			num_crt_hits++;
			crt_x.push_back(crtHit.x_pos);
			crt_y.push_back(crtHit.y_pos);
			crt_z.push_back(crtHit.z_pos);
			crt_mcp_dist.push_back(99999);
			crt_region.push_back(crtHit.plane);
			crt_t.push_back(((double)(int)crtHit.ts1_ns)*1e-3);//  crtTime = ((double)(int)crthit.ts1_ns) * 1e-3;

			int temptrue = bt.TrueIdFromTotalEnergy(event,crtHit);
			crt_trueID.push_back(temptrue);
			crt_PDG.push_back(particles[temptrue].PdgCode());

		}//end loop over crtHits in event

		bool is_first_pt = true;
		TVector3 mcp_this_pos, mcp_last_pos;

		for ( simb::MCTrajectory::const_iterator trajectory = particle.Trajectory().begin(); trajectory != particle.Trajectory().end(); ++trajectory){

			mcp_x.push_back((*trajectory).first.X());
			mcp_y.push_back((*trajectory).first.Y());
			mcp_z.push_back((*trajectory).first.Z());
			mcp_t.push_back((*trajectory).first.T());

			for(int i=0; i<num_crt_hits; i++){

				TVector3 mcp(mcp_x.back(), mcp_y.back(), mcp_z.back());
				TVector3 crt(crt_x[i],crt_y[i],crt_z[i]);

				float tempdist = vect_dist(mcp,crt);
		
				if(tempdist<crt_mcp_dist[i]) crt_mcp_dist[i]=tempdist;

			}//end loop over CRT Hits

			mcp_energy.push_back((*trajectory).second.E());
			mcp_px.push_back((*trajectory).second.Px());
			mcp_py.push_back((*trajectory).second.Py());
			mcp_pz.push_back((*trajectory).second.Pz());

			if(is_first_pt){ 

				mcp_this_pos.SetXYZ(mcp_x.back(),mcp_y.back(),mcp_z.back());
				mcp_track_length = 0;

				mcp_start_x = (*trajectory).first.X();
				mcp_start_y = (*trajectory).first.Y();
				mcp_start_z = (*trajectory).first.Z();
				mcp_start_t = (*trajectory).first.T();

				mcp_start_px = (*trajectory).second.Px();
				mcp_start_py = (*trajectory).second.Py();
				mcp_start_pz = (*trajectory).second.Pz();
				mcp_start_E = (*trajectory).second.E();

				is_first_pt = false;

			}//end if(is_first_pt)
			else {

				mcp_last_pos.SetXYZ(mcp_this_pos.X(),mcp_this_pos.Y(),mcp_this_pos.Z());
				mcp_this_pos.SetXYZ(mcp_x.back(),mcp_y.back(),mcp_z.back());
				mcp_track_length += vect_dist(mcp_this_pos,mcp_last_pos);
				int regioncodes[13] = {30,31,32,33,34,40,41,42,43,44,45,46,47};
				for(int i=0; i<13; i++){

					double temp_mcp_crtcross_x, temp_mcp_crtcross_y, temp_mcp_crtcross_z;
					bool crtcross = crosses_CRT(mcp_this_pos,mcp_last_pos,regioncodes[i],temp_mcp_crtcross_x,temp_mcp_crtcross_y,temp_mcp_crtcross_z);
					if(crtcross) {
						num_crtcross++;
						mcp_crtcross_x.push_back(temp_mcp_crtcross_x); 
						mcp_crtcross_y.push_back(temp_mcp_crtcross_y); 
						mcp_crtcross_z.push_back(temp_mcp_crtcross_z);
						mcp_crtcross_region.push_back(regioncodes[i]);
					}//end if(crtcross)
				}//end loop over region codes

				double temp_mcp_tpccross_x, temp_mcp_tpccross_y, temp_mcp_tpccross_z;
					bool tpccross = crosses_TPC(mcp_this_pos,mcp_last_pos,temp_mcp_tpccross_x,temp_mcp_tpccross_y,temp_mcp_tpccross_z);
					if(tpccross){

						std::cout << "Found crossing point at Y=" << temp_mcp_tpccross_y << std::endl;
						mcp_tpccross_x = temp_mcp_tpccross_x;
						mcp_tpccross_y = temp_mcp_tpccross_y;
						mcp_tpccross_z = temp_mcp_tpccross_z;

					}//end if(tpccross)


			}//end else if not first point

		}//end loop over trajectory points in this MCParticle

		tr_mcparticle->Fill();

	}//end loop over particles in particleHandle



   // tr_mcparticle->Fill();
  } // CRTTruthEff::produce()


void icarus::CRTTruthEff::GetAncestorID(int trueid, int &motherid, int &ancestorid, int &layers, std::map<int, simb::MCParticle> all_particles){

	int size_part = (int)all_particles.size();
	if(trueid<size_part) ancestorid = all_particles[trueid].Mother();
	else ancestorid = trueid;
	motherid = ancestorid;
	int last_ancestorid;
	bool hitbottom = false;
	int counter = 0;
	while(ancestorid%10000000!=0 && counter<1000 && !hitbottom){
		last_ancestorid = ancestorid;
		if(ancestorid<size_part) ancestorid = all_particles[ancestorid].Mother();
		hitbottom = last_ancestorid == ancestorid;
		counter++;
	}//end while loop 
	layers = counter;


}//CRTTruthEff::GetAncestorID
void icarus::CRTTruthEff::getTickRange(std::vector<art::Ptr<recob::Hit>> hits, int &mintick, int &maxtick){

	int tempmin = 4097; int tempmax = -1;

	std::cout << "Found " << (int)hits.size() << " hits to search\n";

	for(int i=0; i<(int)hits.size(); i++){

		int tickhold1 =(int)hits[i]->StartTick(); 
		if(tickhold1>tempmax) tempmax=tickhold1;
		if(tickhold1<tempmin) tempmin=tickhold1;

		int tickhold2 =(int)hits[i]->EndTick(); 
		if(tickhold2>tempmax) tempmax=tickhold2;
		if(tickhold2<tempmin) tempmin=tickhold2;

//		std::cout << "StartTick: " << tickhold1 << "\tEndTick: " << tickhold2 << std::endl;

	}//end loop over hits

	mintick = tempmin; maxtick = tempmax;

}//end definition of void icarus::CRTTruthEff::getTickRange(recob::Track trk, double &mintick, double &maxtick)

void icarus::CRTTruthEff::getCatCrossXYZ(recob::Track trk, double &my_x, double &my_y, double &my_z){

	size_t ntrk = trk.NPoints();
	std::vector<double> x, y, z, x_left_diff, x_right_diff;
//	std::pair<double,double> cathode_yz;
	double left_dist_min = DBL_MAX; int left_dist_min_pos = INT_MAX;
	double right_dist_min = DBL_MAX; int right_dist_min_pos = INT_MAX;
	double xsum=0, xavg;

	int numelmnts = 0;

	//Begin by extracting coordinates into arrays
	for(size_t i=0; i<ntrk; i++){
		geo::Point_t thispt = trk.LocationAtPoint((int)i);
		x.push_back(thispt.X()); y.push_back(thispt.Y()); z.push_back(thispt.Z()); numelmnts++;
		if(std::abs(x.back())<210.215) {
			x_left_diff.push_back(std::abs(std::abs(x[i]) - 210.25));
			if(x_left_diff.back()<=left_dist_min) { left_dist_min=x_left_diff.back(); left_dist_min_pos = i; }
		}//end if(std::abs(x[i])<210.215)
		else if(std::abs(x.back())>=210.215) {
			x_right_diff.push_back(std::abs(std::abs(x[i]) - 210.25));
			if(x_right_diff.back()<=right_dist_min) { right_dist_min=x_right_diff.back(); right_dist_min_pos = i; }
		}//end if(std::abs(x[i])<210.215)
		xsum+=x.back();
	}//end loop over track points
	xavg = xsum/ntrk;

	if(left_dist_min_pos<= (numelmnts-1) && right_dist_min_pos<= (numelmnts-1)) {

		TVector3 leftpt(x[left_dist_min_pos],y[left_dist_min_pos],z[left_dist_min_pos]);
		TVector3 rightpt(x[right_dist_min_pos],y[right_dist_min_pos],z[right_dist_min_pos]);

		//calculate parameters for a line that passes through the two points:
		double mxy = (leftpt.Y() - rightpt.Y())/(leftpt.X()-rightpt.X());
		double mxz = (leftpt.Z() - rightpt.Z())/(leftpt.X()-rightpt.X());

		double bxy = leftpt.Y() - mxy*leftpt.X();
		double bxz = leftpt.Z() - mxz*leftpt.X();

		if(xavg>0) my_x = 210.215; 
		else if(xavg<=0) my_x = -210.215;
		my_y = mxy*my_x + bxy;
		my_z = mxz*my_x + bxz;
	}

}//end definition of std::pair<int,int> getCatCrossYZ(std::vector<art::Ptr<recob::Hit>> trk_hits)
bool icarus::CRTTruthEff::willEnterCRTVolume(TVector3 vecpos, TVector3 vecdir, int crtregion){

	bool returnbool;

	struct boundary_plane{
		double xmin, xmax, ymin, ymax, zmin, zmax;
		int thin_range;//<range of wall that is thinnest, x=0, y=1, z=2
		std::string reg_name; int reg_num;
	};

	boundary_plane all_north_planes[5];

	boundary_plane thisplane;

	if(crtregion==30){
		thisplane.xmin = -550;     thisplane.xmax = 550;
		thisplane.ymin = 617.4;    thisplane.ymax = 617.4;
		thisplane.zmin = -1130;    thisplane.zmax = 1430;
		thisplane.reg_num = 30;	   thisplane.reg_name = "Top Roof";
		thisplane.thin_range = 1;	
	}//end if(crtregion==30)
	else if(crtregion==31){
		thisplane.xmin = 555;     thisplane.xmax = 555;
		thisplane.ymin = 415;     thisplane.ymax = 577;
		thisplane.zmin = -1130;   thisplane.zmax = 1430;
		thisplane.reg_num = 31;	  thisplane.reg_name = "Top Rim West";
		thisplane.thin_range = 0;
	}//end else if(crtregion==31)
	else if(crtregion==32){
		thisplane.xmin = -555;    thisplane.xmax = -555;
		thisplane.ymin = 415;     thisplane.ymax = 577;
		thisplane.zmin = -1130;   thisplane.zmax = 1430;
		thisplane.reg_num = 32;	  thisplane.reg_name = "Top Rim East";
		thisplane.thin_range = 0;
	}//end else if(crtregion==32)
	else if(crtregion==33){
		thisplane.xmin = -540;    thisplane.xmax = 357;
		thisplane.ymin = 415;     thisplane.ymax = 577;
		thisplane.zmin = -1143;   thisplane.zmax = -1143;
		thisplane.reg_num = 33;	  thisplane.reg_name = "Top Rim South";
		thisplane.thin_range = 2;
	}//end else if(crtregion==33)
	else if(crtregion==34){
		thisplane.xmin = -541;    thisplane.xmax = 542;
		thisplane.ymin = 445;     thisplane.ymax = 605;
		thisplane.zmin = -1533;   thisplane.zmax = 1533;
		thisplane.reg_num = 34;	  thisplane.reg_name = "Top Rim North";
		thisplane.thin_range = 2;
	}//end else if(crtregion==34)
	else if(crtregion==40){
		thisplane.xmin = 526.22;    thisplane.xmax = 534.49;
		thisplane.ymin = -300;      thisplane.ymax = 450;
		thisplane.zmin = -1173.34;  thisplane.zmax = 373.34;
		thisplane.reg_num = 40;     thisplane.reg_name = "Side West-South";
		thisplane.thin_range = 0;
	}//end else if(crtregion==40)
	else if(crtregion==41){
		thisplane.xmin = 556.055;   thisplane.xmax = 564.325;
		thisplane.ymin = -280;      thisplane.ymax = 390;
		thisplane.zmin = -407;      thisplane.zmax = 393;
		thisplane.reg_num = 41;     thisplane.reg_name = "Side West-Center";
		thisplane.thin_range = 0;
	}//end else if(crtregion==41)
	else if(crtregion==42){
		thisplane.xmin = 526.22;    thisplane.xmax = 534.49;
		thisplane.ymin = -300;      thisplane.ymax = 450;
		thisplane.zmin = 359.34;    thisplane.zmax = 1159.34;
		thisplane.reg_num = 42;     thisplane.reg_name = "Side West-North";
		thisplane.thin_range = 0;
	}//end else if(crtregion==42)
	else if(crtregion==43){	
		thisplane.xmin = -534.49;   thisplane.xmax = -526.22;
		thisplane.ymin = -260;      thisplane.ymax = 420;
		thisplane.zmin = -1173.34;  thisplane.zmax = 373.34;
		thisplane.reg_num = 43;     thisplane.reg_name = "Side East-South";
		thisplane.thin_range = 0;
	}//end else if(crtregion==43)
	else if(crtregion==44){	
		thisplane.xmin = -564.325;  thisplane.xmax = -556.055;
		thisplane.ymin = -220;      thisplane.ymax = 400;
		thisplane.zmin = -407;      thisplane.zmax = 393;
		thisplane.reg_num = 44;     thisplane.reg_name = "Side East-Center";
		thisplane.thin_range = 0;
	}//end else if(crtregion==44)
	else if(crtregion==45){	
		thisplane.xmin = -534.49;   thisplane.xmax = -526.22;
		thisplane.ymin = -280;      thisplane.ymax = 450;
		thisplane.zmin = 359.34;    thisplane.zmax = 1159.34;
		thisplane.reg_num = 45;     thisplane.reg_name = "Side East-North";
		thisplane.thin_range = 0;
	}//end else if(crtregion==45)
	else if(crtregion==46){	
		thisplane.xmin = -500;       thisplane.xmax = 500;
		thisplane.ymin = -300;       thisplane.ymax = 500;
		thisplane.zmin = -1134.74;   thisplane.zmax = -1120.33;
		thisplane.reg_num = 46;      thisplane.reg_name = "Side South";
		thisplane.thin_range = 2;
	}//end else if(crtregion==46)
	else if(crtregion==47){	
		all_north_planes[0].xmin = -508.275;   all_north_planes[0].xmax = 508.275;
		all_north_planes[0].ymin = 80;         all_north_planes[0].ymax = 320;
		all_north_planes[0].zmin = 1169.72;    all_north_planes[0].zmax = 1177.99;
		all_north_planes[0].reg_num = 47;      all_north_planes[0].reg_name = "Side North Topmost";
		all_north_planes[0].thin_range = 2;

		all_north_planes[1].xmin = -508.275;   all_north_planes[1].xmax = -353.325;
		all_north_planes[1].ymin = -80;	      all_north_planes[1].ymax = 80;
		all_north_planes[1].zmin = 1169.72;    all_north_planes[1].zmax = 1177.99;
		all_north_planes[1].reg_num = 47;      all_north_planes[1].reg_name = "Side North Mid-East";
		all_north_planes[1].thin_range = 2;
	
		all_north_planes[2].xmin = 353.325;    all_north_planes[2].xmax = 508.275;
		all_north_planes[2].ymin = -80;        all_north_planes[2].ymax = 80;
		all_north_planes[2].zmin = 1169.72;    all_north_planes[2].zmax = 1177.99;
		all_north_planes[2].reg_num = 47;      all_north_planes[2].reg_name = "Side North Mid-West";
		all_north_planes[2].thin_range = 2;
	
		all_north_planes[3].xmin = -508.275;   all_north_planes[3].xmax = -380.005;
		all_north_planes[3].ymin = -160;       all_north_planes[3].ymax = -80;
		all_north_planes[3].zmin = 1169.72;    all_north_planes[3].zmax = 1177.99;
		all_north_planes[3].reg_num = 47;      all_north_planes[3].reg_name = "Side North Bottom-East";
		all_north_planes[3].thin_range = 2;
	
		all_north_planes[4].xmin = 380.005;    all_north_planes[4].xmax = 508.275;
		all_north_planes[4].ymin = -160;       all_north_planes[4].ymax = -80;
		all_north_planes[4].zmin = 1169.72;    all_north_planes[4].zmax = 1177.99;
		all_north_planes[4].reg_num = 47;      all_north_planes[4].reg_name = "Side North Bottom-West";
		all_north_planes[4].thin_range = 2;
	}//end else if(crtregion==47)

//bool icarus::CRTTruthEff::willEnterCRTVolume(TVector3 vecpos, TVector3 vecdir, int crtregion)

	if(thisplane.thin_range==0){

//		double thinmin = thisplane.xmin; double thinmax = thisplane.xmax;
		double parameter_tmin = (thisplane.xmin - vecpos.X())/vecdir.X();
		double parameter_tmax = (thisplane.xmax - vecpos.X())/vecdir.X();

		double ycalcmin = vecpos.Y() + vecdir.Y()*parameter_tmin;
		double ycalcmax = vecpos.Y() + vecdir.Y()*parameter_tmax;
		double zcalcmin = vecpos.Z() + vecdir.Z()*parameter_tmin;
		double zcalcmax = vecpos.Z() + vecdir.Z()*parameter_tmax;

		bool ymin_inrange = ycalcmin<=thisplane.ymax && ycalcmin >=thisplane.ymin;
		bool ymax_inrange = ycalcmax<=thisplane.ymax && ycalcmax >=thisplane.ymin;
		bool zmin_inrange = zcalcmin<=thisplane.zmax && zcalcmin >=thisplane.zmin;
		bool zmax_inrange = zcalcmax<=thisplane.zmax && zcalcmax >=thisplane.zmin;

		if(ymin_inrange && zmin_inrange) return true;
		else if(ymax_inrange && zmax_inrange) return true;
		else return false;

	}//end if(thisplane.thin_range==0)
	else if(thisplane.thin_range==1){

//		double thinmin = thisplane.ymin; double thinmax = thisplane.ymax;
		double parameter_tmin = (thisplane.ymin - vecpos.Y())/vecdir.Y();
		double parameter_tmax = (thisplane.ymax - vecpos.Y())/vecdir.Y();

		double xcalcmin = vecpos.X() + vecdir.X()*parameter_tmin;
		double xcalcmax = vecpos.X() + vecdir.X()*parameter_tmax;
		double zcalcmin = vecpos.Z() + vecdir.Z()*parameter_tmin;
		double zcalcmax = vecpos.Z() + vecdir.Z()*parameter_tmax;

		bool xmin_inrange = xcalcmin<=thisplane.xmax && xcalcmin >=thisplane.xmin;
		bool xmax_inrange = xcalcmax<=thisplane.xmax && xcalcmax >=thisplane.xmin;
		bool zmin_inrange = zcalcmin<=thisplane.zmax && zcalcmin >=thisplane.zmin;
		bool zmax_inrange = zcalcmax<=thisplane.zmax && zcalcmax >=thisplane.zmin;

		if(xmin_inrange && zmin_inrange) return true;
		else if(xmax_inrange && zmax_inrange) return true;
		else return false;

	}//end if(thisplane.thin_range==1)
	else if(thisplane.thin_range==2){

//		double thinmin = thisplane.zmin; double thinmax = thisplane.zmax;
		double parameter_tmin = (thisplane.zmin - vecpos.Z())/vecdir.Z();
		double parameter_tmax = (thisplane.zmax - vecpos.Z())/vecdir.Z();

		double xcalcmin = vecpos.X() + vecdir.X()*parameter_tmin;
		double xcalcmax = vecpos.X() + vecdir.X()*parameter_tmax;
		double ycalcmin = vecpos.Y() + vecdir.Y()*parameter_tmin;
		double ycalcmax = vecpos.Y() + vecdir.Y()*parameter_tmax;

		bool xmin_inrange = xcalcmin<=thisplane.xmax && xcalcmin >=thisplane.xmin;
		bool xmax_inrange = xcalcmax<=thisplane.xmax && xcalcmax >=thisplane.xmin;
		bool ymin_inrange = ycalcmin<=thisplane.ymax && ycalcmin >=thisplane.ymin;
		bool ymax_inrange = ycalcmax<=thisplane.ymax && ycalcmax >=thisplane.ymin;

		if(xmin_inrange && ymin_inrange) return true;
		else if(xmax_inrange && ymax_inrange) return true;
		else return false;

	}//end if(thisplane.thin_range==2)

	returnbool=false;
	if(crtregion==47){
		for(int i=0; i<5; i++){
//			double thinmin = all_north_planes[i].zmin; double thinmax = all_north_planes[i].zmax;
			double parameter_tmin = (all_north_planes[i].zmin - vecpos.Z())/vecdir.Z();
			double parameter_tmax = (all_north_planes[i].zmax - vecpos.Z())/vecdir.Z();

			double xcalcmin = vecpos.X() + vecdir.X()*parameter_tmin;
			double xcalcmax = vecpos.X() + vecdir.X()*parameter_tmax;
			double ycalcmin = vecpos.Y() + vecdir.Y()*parameter_tmin;
			double ycalcmax = vecpos.Y() + vecdir.Y()*parameter_tmax;

			bool xmin_inrange = xcalcmin<=all_north_planes[i].xmax && xcalcmin >=all_north_planes[i].xmin;
			bool xmax_inrange = xcalcmax<=all_north_planes[i].xmax && xcalcmax >=all_north_planes[i].xmin;
			bool ymin_inrange = ycalcmin<=all_north_planes[i].ymax && ycalcmin >=all_north_planes[i].ymin;
			bool ymax_inrange = ycalcmax<=all_north_planes[i].ymax && ycalcmax >=all_north_planes[i].ymin;

			if(xmin_inrange && ymin_inrange) returnbool=true;
			else if(xmax_inrange && ymax_inrange) returnbool=true;
		}//end loop over North Wall planes
	}//end if(crt_region==47)
	return returnbool;

}//end definition of bool icarus::CRTTruthEff::willEnterCRTVolume(TVector3 vecpos, TVector3 vecdir, int crtregion)

void icarus::CRTTruthEff::findIntersectingCRTVolume(TVector3 &vecpos, TVector3 &vecdir, int &likely_CRT_region1, int &likely_CRT_region2, int &likely_CRT_region3){


	likely_CRT_region1 = -1; likely_CRT_region2=-1; likely_CRT_region3=-1;

	if(willEnterCRTVolume(vecpos,vecdir,30)) likely_CRT_region1 = 30;
	
	if(willEnterCRTVolume(vecpos,vecdir,31)){ 

		if(likely_CRT_region1==-1) likely_CRT_region1 = 30;
		else likely_CRT_region2 = 31;

	}//end 	if(willEnterCRTVolume(vecpos,vecdir,31))

	if(willEnterCRTVolume(vecpos,vecdir,32)){ 

		if(likely_CRT_region1==-1) likely_CRT_region1 = 32;
		if(likely_CRT_region1!=-1 && likely_CRT_region2==-1) likely_CRT_region2 = 32;
		else likely_CRT_region3 = 32;

	}//end 	if(willEnterCRTVolume(vecpos,vecdir,32))

	if(willEnterCRTVolume(vecpos,vecdir,33)){ 

		if(likely_CRT_region1==-1) likely_CRT_region1 = 33;
		if(likely_CRT_region1!=-1 && likely_CRT_region2==-1) likely_CRT_region2 = 33;
		if(likely_CRT_region1!=-1 && likely_CRT_region2!=-1 && likely_CRT_region3==-1) likely_CRT_region3 = 33;
		if(likely_CRT_region1!=-1 && likely_CRT_region2!=-1 && likely_CRT_region3!=-1) std::cout << "\nAll three slots for predicted CRT regions are filled!\n";

	}//end 	if(willEnterCRTVolume(vecpos,vecdir,33))

	if(willEnterCRTVolume(vecpos,vecdir,34)){ 

		if(likely_CRT_region1==-1) likely_CRT_region1 = 34;
		if(likely_CRT_region1!=-1 && likely_CRT_region2==-1) likely_CRT_region2 = 34;
		if(likely_CRT_region1!=-1 && likely_CRT_region2!=-1 && likely_CRT_region3==-1) likely_CRT_region3 = 34;
		if(likely_CRT_region1!=-1 && likely_CRT_region2!=-1 && likely_CRT_region3!=-1) std::cout << "\nAll three slots for predicted CRT regions are filled!\n";

	}//end 	if(willEnterCRTVolume(vecpos,vecdir,34))

	if(willEnterCRTVolume(vecpos,vecdir,40)){ 

		if(likely_CRT_region1==-1) likely_CRT_region1 = 40;
		if(likely_CRT_region1!=-1 && likely_CRT_region2==-1) likely_CRT_region2 = 40;
		if(likely_CRT_region1!=-1 && likely_CRT_region2!=-1 && likely_CRT_region3==-1) likely_CRT_region3 = 40;
		if(likely_CRT_region1!=-1 && likely_CRT_region2!=-1 && likely_CRT_region3!=-1) std::cout << "\nAll three slots for predicted CRT regions are filled!\n";

	}//end 	if(willEnterCRTVolume(vecpos,vecdir,40))

	if(willEnterCRTVolume(vecpos,vecdir,41)){ 

		if(likely_CRT_region1==-1) likely_CRT_region1 = 41;
		if(likely_CRT_region1!=-1 && likely_CRT_region2==-1) likely_CRT_region2 = 41;
		if(likely_CRT_region1!=-1 && likely_CRT_region2!=-1 && likely_CRT_region3==-1) likely_CRT_region3 = 41;
		if(likely_CRT_region1!=-1 && likely_CRT_region2!=-1 && likely_CRT_region3!=-1) std::cout << "\nAll three slots for predicted CRT regions are filled!\n";

	}//end 	if(willEnterCRTVolume(vecpos,vecdir,41))

	if(willEnterCRTVolume(vecpos,vecdir,42)){ 

		if(likely_CRT_region1==-1) likely_CRT_region1 = 42;
		if(likely_CRT_region1!=-1 && likely_CRT_region2==-1) likely_CRT_region2 = 42;
		if(likely_CRT_region1!=-1 && likely_CRT_region2!=-1 && likely_CRT_region3==-1) likely_CRT_region3 = 42;
		if(likely_CRT_region1!=-1 && likely_CRT_region2!=-1 && likely_CRT_region3!=-1) std::cout << "\nAll three slots for predicted CRT regions are filled!\n";

	}//end 	if(willEnterCRTVolume(vecpos,vecdir,42))

	if(willEnterCRTVolume(vecpos,vecdir,43)){ 

		if(likely_CRT_region1==-1) likely_CRT_region1 = 43;
		if(likely_CRT_region1!=-1 && likely_CRT_region2==-1) likely_CRT_region2 = 43;
		if(likely_CRT_region1!=-1 && likely_CRT_region2!=-1 && likely_CRT_region3==-1) likely_CRT_region3 = 43;
		if(likely_CRT_region1!=-1 && likely_CRT_region2!=-1 && likely_CRT_region3!=-1) std::cout << "\nAll three slots for predicted CRT regions are filled!\n";

	}//end 	if(willEnterCRTVolume(vecpos,vecdir,43))

	if(willEnterCRTVolume(vecpos,vecdir,44)){ 

		if(likely_CRT_region1==-1) likely_CRT_region1 = 44;
		if(likely_CRT_region1!=-1 && likely_CRT_region2==-1) likely_CRT_region2 = 44;
		if(likely_CRT_region1!=-1 && likely_CRT_region2!=-1 && likely_CRT_region3==-1) likely_CRT_region3 = 44;
		if(likely_CRT_region1!=-1 && likely_CRT_region2!=-1 && likely_CRT_region3!=-1) std::cout << "\nAll three slots for predicted CRT regions are filled!\n";

	}//end 	if(willEnterCRTVolume(vecpos,vecdir,44))

	if(willEnterCRTVolume(vecpos,vecdir,45)){ 

		if(likely_CRT_region1==-1) likely_CRT_region1 = 45;
		if(likely_CRT_region1!=-1 && likely_CRT_region2==-1) likely_CRT_region2 = 45;
		if(likely_CRT_region1!=-1 && likely_CRT_region2!=-1 && likely_CRT_region3==-1) likely_CRT_region3 = 45;
		if(likely_CRT_region1!=-1 && likely_CRT_region2!=-1 && likely_CRT_region3!=-1) std::cout << "\nAll three slots for predicted CRT regions are filled!\n";

	}//end 	if(willEnterCRTVolume(vecpos,vecdir,45))

	if(willEnterCRTVolume(vecpos,vecdir,46)){ 

		if(likely_CRT_region1==-1) likely_CRT_region1 = 46;
		if(likely_CRT_region1!=-1 && likely_CRT_region2==-1) likely_CRT_region2 = 46;
		if(likely_CRT_region1!=-1 && likely_CRT_region2!=-1 && likely_CRT_region3==-1) likely_CRT_region3 = 46;
		if(likely_CRT_region1!=-1 && likely_CRT_region2!=-1 && likely_CRT_region3!=-1) std::cout << "\nAll three slots for predicted CRT regions are filled!\n";

	}//end 	if(willEnterCRTVolume(vecpos,vecdir,46))

	if(willEnterCRTVolume(vecpos,vecdir,47)){ 

		if(likely_CRT_region1==-1) likely_CRT_region1 = 47;
		if(likely_CRT_region1!=-1 && likely_CRT_region2==-1) likely_CRT_region2 = 47;
		if(likely_CRT_region1!=-1 && likely_CRT_region2!=-1 && likely_CRT_region3==-1) likely_CRT_region3 = 47;
		if(likely_CRT_region1!=-1 && likely_CRT_region2!=-1 && likely_CRT_region3!=-1) std::cout << "\nAll three slots for predicted CRT regions are filled!\n";

	}//end 	if(willEnterCRTVolume(vecpos,vecdir,47))

/*	if(startorend==0){ 
		auto temp_endpoint = trk.Start();
		auto temp_retvec = trk.StartDirection();

		endpoint.X() = temp_endpoint.X;
		endpoint.Y() = temp_endpoint.Y;
		endpoint.Z() = temp_endpoint.Z;

		retvec.X() = temp_retvec.X;
		retvec.Y() = temp_retvec.Y;
		retvec.Z() = temp_retvec.Z;
	}//end if(startorend==0)
	else if(startorend==1){ 
		auto temp_endpoint = trk.End();
		auto temp_retvec = trk.EndDirection();

		endpoint.X() = temp_endpoint.X;
		endpoint.Y() = temp_endpoint.Y;
		endpoint.Z() = temp_endpoint.Z;

		retvec.X() = temp_retvec.X;
		retvec.Y() = temp_retvec.Y;
		retvec.Z() = temp_retvec.Z;
	}//end if(startorend==0) 

	struct boundary_plane{
		double xmin, xmax, ymin, ymax, zmin, zmax;
		int thin_range;//<range of wall that is thinnest, x=0, y=1, z=2
		std::string reg_name; int reg_num;
	};

	boundary_plane all_top_planes[5], all_side_planes[12];

	all_top_planes[0].xmin = -550;     all_top_planes[0].xmax = 550;
	all_top_planes[0].ymin = 617.4;    all_top_planes[0].ymax = 617.4;
	all_top_planes[0].zmin = -1130;    all_top_planes[0].zmax = 1430;
	all_top_planes[0].reg_num = 30;	   all_top_planes[0].reg_name = "Top Roof";
	all_top_planes[0].thin_range = 1;	
	
	all_top_planes[1].xmin = 555;     all_top_planes[1].xmax = 555;
	all_top_planes[1].ymin = 415;     all_top_planes[1].ymax = 577;
	all_top_planes[1].zmin = -1130;   all_top_planes[1].zmax = 1430;
	all_top_planes[1].reg_num = 31;	  all_top_planes[1].reg_name = "Top Rim West";
	all_top_planes[1].thin_range = 0;
	
	all_top_planes[2].xmin = -555;    all_top_planes[2].xmax = -555;
	all_top_planes[2].ymin = 415;     all_top_planes[2].ymax = 577;
	all_top_planes[2].zmin = -1130;   all_top_planes[2].zmax = 1430;
	all_top_planes[2].reg_num = 32;	  all_top_planes[2].reg_name = "Top Rim East";
	all_top_planes[2].thin_range = 0;

	all_top_planes[3].xmin = -540;    all_top_planes[3].xmax = 357;
	all_top_planes[3].ymin = 415;     all_top_planes[3].ymax = 577;
	all_top_planes[3].zmin = -1143;   all_top_planes[3].zmax = -1143;
	all_top_planes[3].reg_num = 33;	  all_top_planes[3].reg_name = "Top Rim South";
	all_top_planes[3].thin_range = 2;

	all_top_planes[4].xmin = -541;    all_top_planes[4].xmax = 542;
	all_top_planes[4].ymin = 445;     all_top_planes[4].ymax = 605;
	all_top_planes[4].zmin = -1533;   all_top_planes[4].zmax = 1533;
	all_top_planes[4].reg_num = 34;	  all_top_planes[4].reg_name = "Top Rim North";
	all_top_planes[4].thin_range = 2;

	all_side_planes[0].xmin = 526.22;    all_side_planes[0].xmax = 534.49;
	all_side_planes[0].ymin = -300;      all_side_planes[0].ymax = 450;
	all_side_planes[0].zmin = -1173.34;  all_side_planes[0].zmax = 373.34;
	all_side_planes[0].reg_num = 40;     all_side_planes[0].reg_name = "Side West-South";
	all_side_planes[0].thin_range = 0;

	all_side_planes[1].xmin = 556.055;   all_side_planes[1].xmax = 564.325;
	all_side_planes[1].ymin = -280;      all_side_planes[1].ymax = 390;
	all_side_planes[1].zmin = -407;      all_side_planes[1].zmax = 393;
	all_side_planes[1].reg_num = 41;     all_side_planes[1].reg_name = "Side West-Center";
	all_side_planes[1].thin_range = 0;
	
	all_side_planes[2].xmin = 526.22;    all_side_planes[2].xmax = 534.49;
	all_side_planes[2].ymin = -300;      all_side_planes[2].ymax = 450;
	all_side_planes[2].zmin = 359.34;    all_side_planes[2].zmax = 1159.34;
	all_side_planes[2].reg_num = 42;     all_side_planes[2].reg_name = "Side West-North";
	all_side_planes[2].thin_range = 0;
	
	all_side_planes[3].xmin = -534.49;   all_side_planes[3].xmax = -526.22;
	all_side_planes[3].ymin = -260;      all_side_planes[3].ymax = 420;
	all_side_planes[3].zmin = -1173.34;  all_side_planes[3].zmax = 373.34;
	all_side_planes[3].reg_num = 43;     all_side_planes[3].reg_name = "Side East-South";
	all_side_planes[3].thin_range = 0;
	
	all_side_planes[4].xmin = -564.325;  all_side_planes[4].xmax = -556.055;
	all_side_planes[4].ymin = -220;      all_side_planes[4].ymax = 400;
	all_side_planes[4].zmin = -407;      all_side_planes[4].zmax = 393;
	all_side_planes[4].reg_num = 44;     all_side_planes[4].reg_name = "Side East-Center";
	all_side_planes[4].thin_range = 0;
	
	all_side_planes[5].xmin = -534.49;   all_side_planes[5].xmax = -526.22;
	all_side_planes[5].ymin = -280;      all_side_planes[5].ymax = 450;
	all_side_planes[5].zmin = 359.34;    all_side_planes[5].zmax = 1159.34;
	all_side_planes[5].reg_num = 45;     all_side_planes[5].reg_name = "Side East-North";
	all_side_planes[5].thin_range = 0;
	
	all_side_planes[6].xmin = -500;       all_side_planes[6].xmax = 500;
	all_side_planes[6].ymin = -300;       all_side_planes[6].ymax = 500;
	all_side_planes[6].zmin = -1134.74;   all_side_planes[6].zmax = -1120.33;
	all_side_planes[6].reg_num = 46;      all_side_planes[6].reg_name = "Side South";
	all_side_planes[6].thin_range = 2;
	
	all_side_planes[7].xmin = -508.275;   all_side_planes[7].xmax = 508.275;
	all_side_planes[7].ymin = 80;         all_side_planes[7].ymax = 320;
	all_side_planes[7].zmin = 1169.72;    all_side_planes[7].zmax = 1177.99;
	all_side_planes[7].reg_num = 47;      all_side_planes[7].reg_name = "Side North Topmost";
	all_side_planes[7].thin_range = 2;
	
	all_side_planes[8].xmin = -508.275;   all_side_planes[8].xmax = -353.325;
	all_side_planes[8].ymin = -80;	      all_side_planes[8].ymax = 80;
	all_side_planes[8].zmin = 1169.72;    all_side_planes[8].zmax = 1177.99;
	all_side_planes[8].reg_num = 47;      all_side_planes[8].reg_name = "Side North Mid-East";
	all_side_planes[8].thin_range = 2;
	
	all_side_planes[9].xmin = 353.325;    all_side_planes[9].xmax = 508.275;
	all_side_planes[9].ymin = -80;        all_side_planes[9].ymax = 80;
	all_side_planes[9].zmin = 1169.72;    all_side_planes[9].zmax = 1177.99;
	all_side_planes[9].reg_num = 47;      all_side_planes[9].reg_name = "Side North Mid-West";
	all_side_planes[9].thin_range = 2;
	
	all_side_planes[10].xmin = -508.275;   all_side_planes[10].xmax = -380.005;
	all_side_planes[10].ymin = -160;       all_side_planes[10].ymax = -80;
	all_side_planes[10].zmin = 1169.72;    all_side_planes[10].zmax = 1177.99;
	all_side_planes[10].reg_num = 47;      all_side_planes[10].reg_name = "Side North Bottom-East";
	all_side_planes[10].thin_range = 2;
	
	all_side_planes[11].xmin = 380.005;    all_side_planes[11].xmax = 508.275;
	all_side_planes[11].ymin = -160;       all_side_planes[11].ymax = -80;
	all_side_planes[11].zmin = 1169.72;    all_side_planes[11].zmax = 1177.99;
	all_side_planes[11].reg_num = 47;      all_side_planes[11].reg_name = "Side North Bottom-West";
	all_side_planes[11].thin_range = 2;
*/


}//end definition of void icarus::CRTTruthEff::findIntersectingCRTVolume(recob::Track trk, TVector3 &retvec, TVector3 &endpoint, int &likely_CRT_region)

void icarus::CRTTruthEff::endpoint_PCA_ana(recob::Track trk, bool usestartpt, TVector3 &bestfit_dir, TVector3 &bestfit_pos){

	Eigen::Vector3d meanPos(Eigen::Vector3d::Zero());

	//create container for all hit point locations as well as calculate average positions along all axes
	float xavg = 0, yavg = 0, zavg = 0;
	std::vector<TVector3> hit_points;

	size_t firstpt;
	geo::Point_t thispt; geo::Point_t lastpt;
	TVector3 pos_of_endpoint;

	if(usestartpt) {
		std::cout << "Begin by assigning first valid point position....\n";
		firstpt = trk.FirstValidPoint(); 
//		std::cout << "Found first valid point at size_t=" << firstpt << std::endl;
		thispt = trk.LocationAtPoint(firstpt);
		xavg+=thispt.X(); yavg+=thispt.Y(); zavg+=thispt.Z();
		std::cout << "First valid point is at location (x,y,z)=(" << thispt.X() << "," << thispt.Y() << "," << thispt.Z() << ")\n";
		TVector3 temppt(thispt.X(),thispt.Y(),thispt.Z());
		pos_of_endpoint.SetXYZ(thispt.X(),thispt.Y(),thispt.Z());
		hit_points.push_back(temppt);
	}//end if(usestartpt)
	else if(!usestartpt) { 
		std::cout << "Begin by assigning last valid point position....\n";
		firstpt = trk.LastValidPoint(); 
//		std::cout << "Found last valid point at size_t=" << firstpt << std::endl;
		thispt = trk.LocationAtPoint(firstpt);
		xavg+=thispt.X(); yavg+=thispt.Y(); zavg+=thispt.Z();
		std::cout << "Last valid point is at location (x,y,z)=(" << thispt.X() << "," << thispt.Y() << "," << thispt.Z() << ")\n";
		TVector3 temppt(thispt.X(),thispt.Y(),thispt.Z());
		pos_of_endpoint.SetXYZ(thispt.X(),thispt.Y(),thispt.Z());
		hit_points.push_back(temppt);
	}//end else if(!usestartpt)

	float distance_from_endpoint = 0;
	float distlimit = 10;
	int num_points_counter = 1;

	bool forcedbreak = false;

//	std::vector<TVector3> hit_points;

	while(distance_from_endpoint<distlimit || (size_t)num_points_counter<40){
//		std::cout << "Number of points in the track: " << num_points_counter << std::endl;

		size_t nextpt;
		if(usestartpt) {
			nextpt = trk.NextValidPoint(firstpt+1);
//			std::cout << "Found next valid point at size_t=" << nextpt << std::endl;
		}//end if(usestartpt)
		else if(!usestartpt) { 
			nextpt = trk.PreviousValidPoint(firstpt-1);
//			std::cout << "Found previous valid point at size_t=" << nextpt << std::endl;
		}//end else if(!usestartpt)

		if(nextpt==firstpt) {

			std::cout << "Next/previous valid point found to be the same size_t as the one before it! Exiting....\n";
			forcedbreak = true;
			break;

		}//end if(nextpt==firstpt)

		geo::Point_t thispt = trk.LocationAtPoint(nextpt);

		std::cout << "Found next track location at (x,y,z)=(" << thispt.X() << "," << thispt.Y() << "," << thispt.Z() << ")\n";

		xavg+=thispt.X(); yavg+=thispt.Y(); zavg+=thispt.Z();
		TVector3 temppt(thispt.X(),thispt.Y(),thispt.Z());

		distance_from_endpoint = vect_dist(pos_of_endpoint,temppt);

		hit_points.push_back(temppt);

		firstpt = nextpt;

//		std::cout << "Distance between first point and this point: " << distance_from_endpoint << std::endl;

		num_points_counter++;
	}//end loop over points in TPC track, adding to what will eventually go in PCA analysis

	if(!forcedbreak) {

	std::cout << "Number of valid points found within " << distlimit << " cm of the track endpoint: " << hit_points.size() << std::endl;


	xavg = xavg/num_points_counter; yavg = yavg/num_points_counter; zavg = zavg/num_points_counter;
	meanPos(0) = xavg; meanPos(1) = yavg; meanPos(2) = zavg;
	bestfit_pos.SetX(xavg); bestfit_pos.SetY(yavg); bestfit_pos.SetZ(zavg);
	std::cout << "Average (x,y,z) = (" << xavg << "," << yavg << "," << zavg << ")\n";
	//Make covariance matrix now that we have averages
	float xi2 = 0, yi2 = 0, zi2 = 0, xiy = 0, xiz = 0, yiz = 0;
	for(size_t i=0; i<hit_points.size(); i++){

		float tempx = hit_points[i].X() - xavg;
		float tempy = hit_points[i].Y() - yavg;
		float tempz = hit_points[i].Z() - zavg;

		xi2+=(tempx*tempx); yi2+=(tempy*tempy); zi2+=(tempz*tempz);
		xiy+=(tempx*tempy); xiz+=(tempx*tempz); yiz+=(tempy*tempz);

/*		xi2 += (hit_points[i].X() - xavg)*(hit_points[i].X() - xavg);
		yi2 += (hit_points[i].Y() - yavg)*(hit_points[i].Y() - yavg);
		zi2 += (hit_points[i].Z() - zavg)*(hit_points[i].Z() - zavg);
		xiy += (hit_points[i].X() - xavg)*(hit_points[i].Y() - yavg);
		xiz += (hit_points[i].X() - xavg)*(hit_points[i].Z() - zavg);
		yiz += (hit_points[i].Y() - yavg)*(hit_points[i].Z() - zavg);
*/

	}//end loop over points in data
	xi2 = xi2/hit_points.size(); yi2 = yi2/hit_points.size(); zi2 = zi2/hit_points.size();
	xiy = xiy/hit_points.size(); xiz = xiz/hit_points.size(); yiz = yiz/hit_points.size();

	Eigen::Matrix3d covmat; 
	covmat << xi2, xiy, xiz, xiy, yi2, yiz, xiz, yiz, zi2;

	Eigen::SelfAdjointEigenSolver<Eigen::Matrix3d> eigenMat(covmat);

	std::cout << "covariant matrix:\n" << covmat << std::endl;

	if(eigenMat.info() == Eigen::ComputationInfo::Success){

	      reco::PrincipalComponents::EigenValues recobEigenVals = eigenMat.eigenvalues().cast<float>();
	      reco::PrincipalComponents::EigenVectors recobEigenVecs = eigenMat.eigenvectors().cast<float>();

	      std::cout << "Eigenvalues are: " << recobEigenVals(0) << ", " << recobEigenVals(1) << ", " << recobEigenVals(2) << std::endl;

	      float maxeval = FLT_MIN; int maxvalpos = -1;

	      for(int tempindex=0; tempindex<3; tempindex++){

			if(maxeval<(float)recobEigenVals(tempindex)) {

				maxeval = (float)recobEigenVals(tempindex);
				maxvalpos = tempindex;

			}//end if(maxeval<(float)recobEigenVals)

	      }//end for(int tempindex=0; tempindex<3; tempindex++)

	      bestfit_dir.SetXYZ(recobEigenVecs(0,maxvalpos), recobEigenVecs(1,maxvalpos), recobEigenVecs(2,maxvalpos));

	}//end if(eigenMat.info() == Eigen::ComputationInfo::Success)

	}//end if(!forcedbreak)
	std::cout << "End endpoint_PCA_ana function............\n-----------------------------------------\n\n\n";

}//end definition of void endpoint_PCA_ana(recob::Track trk, int startorend, TVector3 &bestfit_dir, TVector3 &bestfit_pos)

void icarus::CRTTruthEff::pointChecker(recob::Track trk, bool &startisinTPC, bool &endisinTPC, int &startflag, int &endflag){

	geo::Point_t startpoint = trk.Start();
	geo::Point_t endpoint = trk.End();

	float xmin = 61.94;    float xmax = 358.49;
	float ymin = -181.86;  float ymax = 134.96;
	float zmin = -894.951; float zmax = 894.951;

	bool x_start_check, x_end_check, y_start_check, y_end_check, z_start_check, z_end_check;

	x_start_check = std::abs(startpoint.X())>=xmin && std::abs(startpoint.X())<=xmax;
	x_end_check = std::abs(endpoint.X())>=xmin && std::abs(endpoint.X())<=xmax;
	y_start_check = startpoint.Y()>=ymin && startpoint.Y()<=ymax;
	y_end_check = endpoint.Y()>=ymin && endpoint.Y()<=ymax;
	z_start_check = startpoint.Z()>=zmin && startpoint.Z()<=zmax;
	z_end_check = endpoint.Z()>=zmin && endpoint.Z()<=zmax;

	startisinTPC = x_start_check && y_start_check && z_start_check;
	endisinTPC = x_end_check && y_end_check && z_end_check;

	startflag=-1; endflag=-1;

	if(startisinTPC) startflag=0;
	else if(!x_start_check && y_start_check && z_start_check) startflag=1;
	else if(x_start_check && !y_start_check && z_start_check) startflag=2;
	else if(x_start_check && y_start_check && !z_start_check) startflag=3;
	else startflag=4;
	if(endisinTPC) endflag=0;
	else if(!x_end_check && y_end_check && z_end_check) endflag=1;
	else if(x_end_check && !y_end_check && z_end_check) endflag=2;
	else if(x_end_check && y_end_check && !z_end_check) endflag=3;
	else endflag=4;

}//end definition of void icarus::CRTTruthEff::pointChecker(recob::Track trk, bool &startisinTPC, bool &endisinTPC)

double icarus::CRTTruthEff::getnewDCA(TVector3 CRTHitpos, TVector3 TPC_posvec, TVector3 TPC_dirvec){

    double denominator = TPC_dirvec.Mag();
    double numerator = (CRTHitpos - TPC_posvec).Cross(CRTHitpos - TPC_posvec - TPC_dirvec).Mag();
    return numerator/denominator;


}//end definition of double icarus::CRTTruthEff::getnewDCA(TVector3 CRTHitpos, TVector3 TPC_posvec, TVector3 TPC_dirvec)

float icarus::CRTTruthEff::vect_dist(TVector3 vec1, TVector3 vec2){

//	std::cout << "finding distance between two vectors.\n";
//	std::cout << "vector 1 (x,y,z):\t(" << vec1.X() << "," << vec1.Y() << "," << vec1.Z() << ")\n"; 
//	std::cout << "vector 2 (x,y,z):\t(" << vec2.X() << "," << vec2.Y() << "," << vec2.Z() << ")\n"; 

	float xdiff = vec1.X()-vec2.X();
	float ydiff = vec1.Y()-vec2.Y();
	float zdiff = vec1.Z()-vec2.Z();

//	std::cout << "Difference in X:\t" << xdiff << std::endl;
//	std::cout << "Difference in Y:\t" << ydiff << std::endl;
//	std::cout << "Difference in Z:\t" << zdiff << std::endl;

	xdiff=xdiff*xdiff; ydiff=ydiff*ydiff; zdiff=zdiff*zdiff;

//	std::cout << "Difference^2 in X:\t" << xdiff << std::endl;
//	std::cout << "Difference^2 in Y:\t" << ydiff << std::endl;
//	std::cout << "Difference^2 in Z:\t" << zdiff << std::endl;

	float returnval = std::sqrt(xdiff+ydiff+zdiff);

//	std::cout << "distance betwen vectors found to be:\t" << returnval << std::endl;

	return returnval;


}//end definition of double icarus::CRTTruthEff::vect_dist(TVector3 vec1, TVector3 vec2)

double icarus::CRTTruthEff::CRT_plane_dist(TVector3 TPC_track_pos, TVector3 TPC_track_dir, TVector3 CRT_hit_pos, int plane_axis/*0 for x, 1 for y, 2 for z*/){

	double tfactor, returnval = -1;
	TVector3 TPC_track_cross_CRTmodpt;

	if(plane_axis==0){

		tfactor = (CRT_hit_pos.X() - TPC_track_pos.X())/TPC_track_dir.X();
		
		TPC_track_cross_CRTmodpt.SetX(CRT_hit_pos.X());
		TPC_track_cross_CRTmodpt.SetY(TPC_track_pos.Y()+TPC_track_dir.Y()*tfactor);
		TPC_track_cross_CRTmodpt.SetZ(TPC_track_pos.Z()+TPC_track_dir.Z()*tfactor);

		double ydiff, zdiff;
		ydiff = TPC_track_cross_CRTmodpt.Y() - CRT_hit_pos.Y();
		zdiff = TPC_track_cross_CRTmodpt.Z() - CRT_hit_pos.Z();

		returnval = sqrt(ydiff*ydiff + zdiff*zdiff);

	}//end if(plane_axis==0)
	else if(plane_axis==1){

		tfactor = (CRT_hit_pos.Y() - TPC_track_pos.Y())/TPC_track_dir.Y();
		
		TPC_track_cross_CRTmodpt.SetX(TPC_track_pos.X()+TPC_track_dir.X()*tfactor);
		TPC_track_cross_CRTmodpt.SetY(CRT_hit_pos.Y());
		TPC_track_cross_CRTmodpt.SetZ(TPC_track_pos.Z()+TPC_track_dir.Z()*tfactor);

		double xdiff, zdiff;
		xdiff = TPC_track_cross_CRTmodpt.X() - CRT_hit_pos.X();
		zdiff = TPC_track_cross_CRTmodpt.Z() - CRT_hit_pos.Z();

		returnval = sqrt(xdiff*xdiff + zdiff*zdiff);

	}//end else if (plane_axis==1)
	else if(plane_axis==2){

		tfactor = (CRT_hit_pos.Z() - TPC_track_pos.Z())/TPC_track_dir.Z();
		
		TPC_track_cross_CRTmodpt.SetX(TPC_track_pos.X()+TPC_track_dir.X()*tfactor);
		TPC_track_cross_CRTmodpt.SetY(TPC_track_pos.Y()+TPC_track_dir.Y()*tfactor);
		TPC_track_cross_CRTmodpt.SetZ(CRT_hit_pos.Z());

		double ydiff, xdiff;
		ydiff = TPC_track_cross_CRTmodpt.Y() - CRT_hit_pos.Y();
		xdiff = TPC_track_cross_CRTmodpt.X() - CRT_hit_pos.X();

		returnval = sqrt(ydiff*ydiff + xdiff*xdiff);

	}//end else if(plane_axis==2)

	return returnval;


}//end double icarus::CRTTruthEff::CRT_plane_dist(TVector3 TPC_track_pos, TVector3 TPC_track_dir, TVector3 CRT_hit_pos, int plane_axis/*0 for x, 1 for y, 2 for z*/)

bool icarus::CRTTruthEff::crosses_CRT(TVector3 pos1, TVector3 pos2, int crtregion, double &crossx, double &crossy, double &crossz){

	struct boundary_plane{
		double xmin, xmax, ymin, ymax, zmin, zmax;
		int thin_range;//<range of wall that is thinnest, x=0, y=1, z=2
		std::string reg_name; int reg_num;
	};

	boundary_plane all_north_planes[5];

	boundary_plane thisplane;

	if(crtregion==30){
		thisplane.xmin = -550;     thisplane.xmax = 550;
		thisplane.ymin = 617.4;    thisplane.ymax = 617.4;
		thisplane.zmin = -1130;    thisplane.zmax = 1430;
		thisplane.reg_num = 30;	   thisplane.reg_name = "Top Roof";
		thisplane.thin_range = 1;	
	}//end if(crtregion==30)
	else if(crtregion==31){
		thisplane.xmin = 555;     thisplane.xmax = 555;
		thisplane.ymin = 415;     thisplane.ymax = 577;
		thisplane.zmin = -1130;   thisplane.zmax = 1430;
		thisplane.reg_num = 31;	  thisplane.reg_name = "Top Rim West";
		thisplane.thin_range = 0;
	}//end else if(crtregion==31)
	else if(crtregion==32){
		thisplane.xmin = -555;    thisplane.xmax = -555;
		thisplane.ymin = 415;     thisplane.ymax = 577;
		thisplane.zmin = -1130;   thisplane.zmax = 1430;
		thisplane.reg_num = 32;	  thisplane.reg_name = "Top Rim East";
		thisplane.thin_range = 0;
	}//end else if(crtregion==32)
	else if(crtregion==33){
		thisplane.xmin = -540;    thisplane.xmax = 357;
		thisplane.ymin = 415;     thisplane.ymax = 577;
		thisplane.zmin = -1143;   thisplane.zmax = -1143;
		thisplane.reg_num = 33;	  thisplane.reg_name = "Top Rim South";
		thisplane.thin_range = 2;
	}//end else if(crtregion==33)
	else if(crtregion==34){
		thisplane.xmin = -541;    thisplane.xmax = 542;
		thisplane.ymin = 445;     thisplane.ymax = 605;
		thisplane.zmin = -1533;   thisplane.zmax = 1533;
		thisplane.reg_num = 34;	  thisplane.reg_name = "Top Rim North";
		thisplane.thin_range = 2;
	}//end else if(crtregion==34)
	else if(crtregion==40){
		thisplane.xmin = 526.22;    thisplane.xmax = 534.49;
		thisplane.ymin = -300;      thisplane.ymax = 450;
		thisplane.zmin = -1173.34;  thisplane.zmax = 373.34;
		thisplane.reg_num = 40;     thisplane.reg_name = "Side West-South";
		thisplane.thin_range = 0;
	}//end else if(crtregion==40)
	else if(crtregion==41){
		thisplane.xmin = 556.055;   thisplane.xmax = 564.325;
		thisplane.ymin = -280;      thisplane.ymax = 390;
		thisplane.zmin = -407;      thisplane.zmax = 393;
		thisplane.reg_num = 41;     thisplane.reg_name = "Side West-Center";
		thisplane.thin_range = 0;
	}//end else if(crtregion==41)
	else if(crtregion==42){
		thisplane.xmin = 526.22;    thisplane.xmax = 534.49;
		thisplane.ymin = -300;      thisplane.ymax = 450;
		thisplane.zmin = 359.34;    thisplane.zmax = 1159.34;
		thisplane.reg_num = 42;     thisplane.reg_name = "Side West-North";
		thisplane.thin_range = 0;
	}//end else if(crtregion==42)
	else if(crtregion==43){	
		thisplane.xmin = -534.49;   thisplane.xmax = -526.22;
		thisplane.ymin = -260;      thisplane.ymax = 420;
		thisplane.zmin = -1173.34;  thisplane.zmax = 373.34;
		thisplane.reg_num = 43;     thisplane.reg_name = "Side East-South";
		thisplane.thin_range = 0;
	}//end else if(crtregion==43)
	else if(crtregion==44){	
		thisplane.xmin = -564.325;  thisplane.xmax = -556.055;
		thisplane.ymin = -220;      thisplane.ymax = 400;
		thisplane.zmin = -407;      thisplane.zmax = 393;
		thisplane.reg_num = 44;     thisplane.reg_name = "Side East-Center";
		thisplane.thin_range = 0;
	}//end else if(crtregion==44)
	else if(crtregion==45){	
		thisplane.xmin = -534.49;   thisplane.xmax = -526.22;
		thisplane.ymin = -280;      thisplane.ymax = 450;
		thisplane.zmin = 359.34;    thisplane.zmax = 1159.34;
		thisplane.reg_num = 45;     thisplane.reg_name = "Side East-North";
		thisplane.thin_range = 0;
	}//end else if(crtregion==45)
	else if(crtregion==46){	
		thisplane.xmin = -500;       thisplane.xmax = 500;
		thisplane.ymin = -300;       thisplane.ymax = 500;
		thisplane.zmin = -1134.74;   thisplane.zmax = -1120.33;
		thisplane.reg_num = 46;      thisplane.reg_name = "Side South";
		thisplane.thin_range = 2;
	}//end else if(crtregion==46)
	else if(crtregion==47){	
		all_north_planes[0].xmin = -508.275;   all_north_planes[0].xmax = 508.275;
		all_north_planes[0].ymin = 80;         all_north_planes[0].ymax = 320;
		all_north_planes[0].zmin = 1169.72;    all_north_planes[0].zmax = 1177.99;
		all_north_planes[0].reg_num = 47;      all_north_planes[0].reg_name = "Side North Topmost";
		all_north_planes[0].thin_range = 2;

		all_north_planes[1].xmin = -508.275;   all_north_planes[1].xmax = -353.325;
		all_north_planes[1].ymin = -80;	      all_north_planes[1].ymax = 80;
		all_north_planes[1].zmin = 1169.72;    all_north_planes[1].zmax = 1177.99;
		all_north_planes[1].reg_num = 47;      all_north_planes[1].reg_name = "Side North Mid-East";
		all_north_planes[1].thin_range = 2;
	
		all_north_planes[2].xmin = 353.325;    all_north_planes[2].xmax = 508.275;
		all_north_planes[2].ymin = -80;        all_north_planes[2].ymax = 80;
		all_north_planes[2].zmin = 1169.72;    all_north_planes[2].zmax = 1177.99;
		all_north_planes[2].reg_num = 47;      all_north_planes[2].reg_name = "Side North Mid-West";
		all_north_planes[2].thin_range = 2;
	
		all_north_planes[3].xmin = -508.275;   all_north_planes[3].xmax = -380.005;
		all_north_planes[3].ymin = -160;       all_north_planes[3].ymax = -80;
		all_north_planes[3].zmin = 1169.72;    all_north_planes[3].zmax = 1177.99;
		all_north_planes[3].reg_num = 47;      all_north_planes[3].reg_name = "Side North Bottom-East";
		all_north_planes[3].thin_range = 2;
	
		all_north_planes[4].xmin = 380.005;    all_north_planes[4].xmax = 508.275;
		all_north_planes[4].ymin = -160;       all_north_planes[4].ymax = -80;
		all_north_planes[4].zmin = 1169.72;    all_north_planes[4].zmax = 1177.99;
		all_north_planes[4].reg_num = 47;      all_north_planes[4].reg_name = "Side North Bottom-West";
		all_north_planes[4].thin_range = 2;
	}//end else if(crtregion==47)

	double x_start = pos1.X(); double y_start = pos1.Y(); double z_start = pos1.Z();
	double x_end = pos2.X(); double y_end = pos2.Y(); double z_end = pos2.Z();
	double x_vec = x_start - x_end; double y_vec = y_start - y_end; double z_vec = z_start - z_end;

	if(thisplane.thin_range == 0){

		double tmin = (thisplane.xmin - x_end)/(x_start - x_end);
		double tmax = (thisplane.xmax - x_end)/(x_start - x_end);
		bool crossmin = tmin>=0 && tmin<=1;
		bool crossmax = tmax>=0 && tmax<=1;

		if(crossmin && !crossmax){
			crossx = x_end+x_vec*tmin; crossy = y_end + y_vec*tmin; crossz = z_end + z_vec*tmin;
			if(crossy>=thisplane.ymin && crossy<=thisplane.ymax && crossz>=thisplane.zmin && crossz<=thisplane.zmax){
				return true;
			}//end check that other 2 points are on plane
			else return false;
		}//end if(crossmin && !crossmax)
		else if(!crossmin && crossmax){
			crossx = x_end+x_vec*tmax; crossy = y_end + y_vec*tmax; crossz = z_end + z_vec*tmax;
			if(crossy>=thisplane.ymin && crossy<=thisplane.ymax && crossz>=thisplane.zmin && crossz<=thisplane.zmax){
				return true;
			}//end check that other 2 dimensions lie within plane
			else return false;
		}//end else if(!crossmin && crossmax)
		else if(crossmin && crossmax){
			crossx = thisplane.xmin+((thisplane.xmax-thisplane.xmin)/2); 
			double crosst = (crossx - x_end)/(x_start - x_end);
			crossy = y_end + y_vec*crosst; 
			crossz = z_end + z_vec*crosst;
			if(crossy>=thisplane.ymin && crossy<=thisplane.ymax && crossz>=thisplane.zmin && crossz<=thisplane.zmax){
				return true;
			}//end check that other 2 dimensions lie within plane
			else return false;
		}//end else if(crossmin && crossmax)
		else return false;

	}//end if(thisplane.thin_range == 0)
	else if(thisplane.thin_range == 1){

		double tmin = (thisplane.ymin - y_end)/(y_start - y_end);
		double tmax = (thisplane.ymax - y_end)/(y_start - y_end);
		bool crossmin = tmin>=0 && tmin<=1;
		bool crossmax = tmax>=0 && tmax<=1;

		if(crossmin && !crossmax){
			crossx = x_end + x_vec*tmin; crossy = y_end+y_vec*tmin; crossz = z_end + z_vec*tmin;
			if(crossx>=thisplane.xmin && crossx<=thisplane.xmax && crossz>=thisplane.zmin && crossz<=thisplane.zmax){
				return true;
			}//end check that other 2 points are on plane
			else return false;
		}//end if(crossmin && !crossmax)
		else if(!crossmin && crossmax){
			crossx = x_end+x_vec*tmax; crossy = y_end+y_vec*tmax; crossz = z_end + z_vec*tmax;
			if(crossx>=thisplane.xmin && crossx<=thisplane.xmax && crossz>=thisplane.zmin && crossz<=thisplane.zmax){
				return true;
			}//end check that other 2 dimensions lie within plane
			else return false;
		}//end else if(!crossmin && crossmax)
		else if(crossmin && crossmax){
			crossy = thisplane.ymin+((thisplane.ymax-thisplane.ymin)/2); 
			double crosst = (crossy - y_end)/(y_start - y_end);
			crossx = x_end + x_vec*crosst; 
			crossz = z_end + z_vec*crosst;
			if(crossx>=thisplane.xmin && crossx<=thisplane.xmax && crossz>=thisplane.zmin && crossz<=thisplane.zmax){
				return true;
			}//end check that other 2 dimensions lie within plane
			else return false;
		}//end else if(crossmin && crossmax)
		else return false;

	}//end if(thisplane.thin_range == 0)
	if(thisplane.thin_range == 2){

		double tmin = (thisplane.zmin - z_end)/(z_start - z_end);
		double tmax = (thisplane.zmax - z_end)/(z_start - z_end);
		bool crossmin = tmin>=0 && tmin<=1;
		bool crossmax = tmax>=0 && tmax<=1;

		if(crossmin && !crossmax){
			crossx = x_end + x_vec*tmin; crossy = y_end + y_vec*tmin; crossz = z_end +z_vec*tmin;
			if(crossx>=thisplane.xmin && crossx<=thisplane.xmax && crossy>=thisplane.ymin && crossy<=thisplane.ymax){
				return true;
			}//end check that other 2 points are on plane
			else return false;
		}//end if(crossmin && !crossmax)
		else if(!crossmin && crossmax){
			crossx = x_end+x_vec*tmax; crossy = y_end+y_vec*tmax; crossz = z_end + z_vec*tmax;
			if(crossx>=thisplane.xmin && crossx<=thisplane.xmax && crossz>=thisplane.zmin && crossz<=thisplane.zmax){
				return true;
			}//end check that other 2 dimensions lie within plane
			else return false;
		}//end else if(!crossmin && crossmax)
		else if(crossmin && crossmax){
			crossz = thisplane.zmin+((thisplane.zmax-thisplane.zmin)/2); 
			double crosst = (crossz - z_end)/(z_start - z_end);
			crossx = x_end + x_vec*crosst; 
			crossy = y_end + y_vec*crosst;
			if(crossx>=thisplane.xmin && crossx<=thisplane.xmax && crossy>=thisplane.ymin && crossy<=thisplane.ymax){
				return true;
			}//end check that other 2 dimensions lie within plane
			else return false;
		}//end else if(crossmin && crossmax)
		else return false;

	}//end if(thisplane.thin_range == 2)
	else return false;

}//end bool crosses_CRT
int icarus::CRTTruthEff::CRT_region_code(std::string reg){

    if(reg == "Top")        return 30;
    else if(reg == "RimWest")    return 31;
    else if(reg == "RimEast")    return 32;
    else if(reg == "RimSouth")   return 33;
    else if(reg == "RimNorth")   return 34;
    else if(reg == "WestSouth")  return 40;
    else if(reg == "WestCenter") return 41;
    else if(reg == "WestNorth")  return 42;
    else if(reg == "EastSouth")  return 43;
    else if(reg == "EastCenter") return 44;
    else if(reg == "EastNorth")  return 45;
    else if(reg == "South")      return 46;
    else if(reg == "North")      return 47;
    else if(reg == "Bottom")     return 50;
    else return 99;

}//end int icarus::CRTTruthEff::CRT_region_code(std::string string1)

bool icarus::CRTTruthEff::crosses_TPC(TVector3 pos1, TVector3 pos2, double &crossx, double &crossy, double &crossz){

	double tpc_top_y = 134.96;
	bool onbothsides = (pos1.Y()>=tpc_top_y && pos2.Y()<=tpc_top_y) || (pos1.Y()<=tpc_top_y && pos2.Y()>=tpc_top_y);

	if(onbothsides){

		double xvec = pos1.X() - pos2.X();
		double yvec = pos1.Y() - pos2.Y();
		double zvec = pos1.Z() - pos2.Z();

		double tfact = (tpc_top_y - pos2.Y())/yvec;

		if(tfact>1||tfact<0){

			std::cout <<"\nt factor has ineligible value!\n";
			return false;

		}//end if(tfact>1||tfact<0
		else{
			crossx = pos2.X() + tfact*xvec;
			crossy = tpc_top_y;
			crossz = pos2.Z() + tfact*zvec;
			return true;
		}

	}//end if(onbothsides)
	else return false;


}//end 

  DEFINE_ART_MODULE(CRTTruthEff)

} // icarus namespace


